{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udc0d TaipanStack","text":"<p>The Modern Python Foundation \u2014 Launch secure, high-performance Python applications in seconds.</p> <p> </p>"},{"location":"#why-taipanstack","title":"\u2728 Why TaipanStack?","text":"<p>\"Write less, build better.\"</p> <p>TaipanStack is a battle-tested foundation for production-grade Python projects that combines security, performance, and developer experience into a single, cohesive toolkit.</p> <ul> <li> <p>:shield: Security First</p> <p>Path traversal protection, command injection guards, input sanitizers &amp; validators, secret detection, SBOM + SLSA attestation.</p> </li> <li> <p>:zap: High Performance</p> <p><code>uvloop</code> async event loop, <code>orjson</code> fast JSON, <code>Pydantic v2</code> validation, pytest-benchmark regression detection.</p> </li> <li> <p>:dart: Rust-Style Error Handling</p> <p><code>Ok</code>/<code>Err</code> Result types, explicit error propagation, pattern matching, no silent failures.</p> </li> <li> <p>:wrench: Developer Experience</p> <p>Pre-configured quality tools, 100% code coverage (683 tests), architecture enforcement, hardened Docker template.</p> </li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#from-pypi","title":"From PyPI","text":"<pre><code>pip install taipanstack\n</code></pre>"},{"location":"#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/gabrielima7/TaipanStack.git\ncd TaipanStack\npoetry install --with dev\n</code></pre>"},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code># Run tests with 100% coverage\nmake test\n\n# Check architecture contracts\nmake lint-imports\n\n# Run security scans\nmake security\n</code></pre>"},{"location":"#api-highlights","title":"\ud83d\udcda API Highlights","text":""},{"location":"#result-types","title":"Result Types","text":"<pre><code>from taipanstack.core.result import Result, Ok, Err, safe\n\n@safe\ndef divide(a: int, b: int) -&gt; float:\n    return a / b\n\nmatch divide(10, 0):\n    case Ok(value):\n        print(f\"Result: {value}\")\n    case Err(error):\n        print(f\"Error: {error}\")\n</code></pre>"},{"location":"#security-guards","title":"Security Guards","text":"<pre><code>from taipanstack.security.guards import guard_path_traversal, guard_command_injection\n\nsafe_path = guard_path_traversal(user_input, base_dir=\"/app/data\")\nsafe_cmd = guard_command_injection([\"git\", \"clone\", repo_url], allowed_commands=[\"git\"])\n</code></pre>"},{"location":"#retry-circuit-breaker","title":"Retry + Circuit Breaker","text":"<pre><code>from taipanstack.utils.retry import retry\nfrom taipanstack.utils.circuit_breaker import circuit_breaker\n\n@circuit_breaker(failure_threshold=5, timeout=30)\n@retry(max_attempts=3, on=(ConnectionError, TimeoutError))\ndef call_external_service() -&gt; dict:\n    return service.call()\n</code></pre>"},{"location":"#architecture","title":"\ud83d\udcd0 Architecture","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502             Application             \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u25bc                           \u25bc                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Security     \u2502       \u2502     Config      \u2502       \u2502     Utils       \u2502\n\u2502 guards, saniti- \u2502       \u2502    models,      \u2502       \u2502  logging, retry \u2502\n\u2502 zers, validators\u2502       \u2502   generators    \u2502       \u2502 metrics, fs     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                         \u2502                         \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502              Core                   \u2502\n                    \u2502    Result types, base patterns      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Read the full architecture guide \u2192</p>"},{"location":"#devsecops","title":"\ud83d\udd10 DevSecOps","text":"Category Tools Purpose SAST Bandit, Semgrep + custom rules Static Application Security Testing SCA Safety, pip-audit Dependency vulnerability scanning SBOM Syft (CycloneDX) Software Bill of Materials SLSA Cosign (Sigstore) Artifact signing &amp; attestation Types Mypy (strict) Compile-time type checking Lint Ruff Lightning-fast linting &amp; formatting Arch Import Linter Dependency rule enforcement Test Pytest, Hypothesis, mutmut Property-based &amp; mutation testing Perf pytest-benchmark Performance regression detection"},{"location":"#live-reports","title":"\ud83d\udcca Live Reports","text":"Report Description \ud83e\uddea Coverage Report Full HTML coverage report \u2014 100% (683 tests) \u26a1 Benchmark Dashboard Performance history &amp; regression graphs"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! See the Contributing Guide for details.</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>Open-sourced under the MIT License.</p>"},{"location":"architecture/","title":"TaipanStack Architecture","text":"<p>TaipanStack is built on the philosophy of maximum safety by default, combined with blazing-fast asynchronous programming. The internal architecture enforces a strict layered dependency map, statically verified on every commit.</p>"},{"location":"architecture/#layered-dependency-model","title":"Layered Dependency Model","text":"<p>The architecture enforces unidirectional data flow. Upper layers may import from lower layers; lower layers may never import upward.</p> <pre><code>graph TD\n    A[\"\ud83c\udfe2 Application Layer&lt;br/&gt;(your business logic)\"]\n    B[\"\ud83d\udee1\ufe0f Security Layer&lt;br/&gt;guards \u00b7 sanitizers \u00b7 validators \u00b7 decorators\"]\n    C[\"\u2699\ufe0f Config Layer&lt;br/&gt;models \u00b7 generators \u00b7 version_config\"]\n    D[\"\ud83d\udd27 Utils Layer&lt;br/&gt;retry \u00b7 circuit_breaker \u00b7 metrics \u00b7 logging \u00b7 filesystem\"]\n    E[\"\ud83c\udfaf Core Layer&lt;br/&gt;result \u00b7 compat \u00b7 optimizations\"]\n\n    A --&gt; B\n    A --&gt; C\n    A --&gt; D\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n\n    style A fill:#4A148C,color:#fff\n    style B fill:#880E4F,color:#fff\n    style C fill:#1A237E,color:#fff\n    style D fill:#004D40,color:#fff\n    style E fill:#BF360C,color:#fff</code></pre>"},{"location":"architecture/#dependency-contracts-import-linter","title":"Dependency Contracts (Import Linter)","text":"<p>These contracts are enforced statically in CI via Import Linter. Any violation fails the build immediately.</p> Contract Rule <code>core</code> is independent <code>taipanstack.core</code> cannot import from <code>security</code>, <code>utils</code>, or <code>config</code> <code>security</code> is independent <code>taipanstack.security</code> cannot import from <code>utils</code> or <code>config</code> <code>utils</code> is independent <code>taipanstack.utils</code> cannot import from <code>security</code> or <code>config</code> <code>config</code> only uses <code>core</code> <code>taipanstack.config</code> cannot import from <code>security</code> or <code>utils</code>"},{"location":"architecture/#project-structure","title":"Project Structure","text":"<pre><code>TaipanStack/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 taipanstack/\n\u2502       \u251c\u2500\u2500 __init__.py       # Public API surface\n\u2502       \u251c\u2500\u2500 core/             # \ud83c\udfaf Result types, compat, optimizations\n\u2502       \u2502   \u251c\u2500\u2500 result.py     #    Ok / Err / safe / unwrap_or\n\u2502       \u2502   \u251c\u2500\u2500 compat.py     #    Python version feature flags\n\u2502       \u2502   \u2514\u2500\u2500 optimizations.py # uvloop / orjson bootstrap\n\u2502       \u251c\u2500\u2500 config/           # \u2699\ufe0f Configuration models &amp; generators\n\u2502       \u2502   \u251c\u2500\u2500 models.py     #    StackConfig (Pydantic v2)\n\u2502       \u2502   \u251c\u2500\u2500 generators.py #    Project scaffolding templates\n\u2502       \u2502   \u2514\u2500\u2500 version_config.py # Version-aware recommendations\n\u2502       \u251c\u2500\u2500 security/         # \ud83d\udee1\ufe0f Guards, sanitizers, validators\n\u2502       \u2502   \u251c\u2500\u2500 guards.py     #    Path traversal, command injection, env guards\n\u2502       \u2502   \u251c\u2500\u2500 sanitizers.py #    XSS, filename, SQL, env value sanitization\n\u2502       \u2502   \u251c\u2500\u2500 validators.py #    Email, URL, project name, Python version\n\u2502       \u2502   \u2514\u2500\u2500 decorators.py #    @safe_path, @safe_env wrappers\n\u2502       \u2514\u2500\u2500 utils/            # \ud83d\udd27 Resilience &amp; observability utilities\n\u2502           \u251c\u2500\u2500 circuit_breaker.py # Circuit breaker with on_state_change callback\n\u2502           \u251c\u2500\u2500 retry.py           # Exponential backoff with on_retry callback\n\u2502           \u251c\u2500\u2500 metrics.py         # @timed, @counted decorators\n\u2502           \u251c\u2500\u2500 logging.py         # Structured logging (structlog)\n\u2502           \u251c\u2500\u2500 filesystem.py      # Safe file operations\n\u2502           \u2514\u2500\u2500 subprocess.py      # Sandboxed subprocess execution\n\u251c\u2500\u2500 tests/                    # \u2705 683 tests, 100% coverage\n\u2502   \u251c\u2500\u2500 test_benchmarks.py    # pytest-benchmark performance suite\n\u2502   \u251c\u2500\u2500 test_property_sanitizers.py # Hypothesis fuzzing\n\u2502   \u2514\u2500\u2500 test_v031_features.py # v0.3.1 specific new behaviors\n\u251c\u2500\u2500 docs/                     # \ud83d\udcd6 MkDocs Material documentation\n\u251c\u2500\u2500 .semgrep/                 # \ud83d\udd0d Custom SAST rules\n\u251c\u2500\u2500 .github/                  # \ud83d\udd04 CI/CD + SBOM/SLSA + Docs workflows\n\u251c\u2500\u2500 Dockerfile                # \ud83d\udc33 Hardened multi-stage container\n\u2514\u2500\u2500 pyproject.toml            # \ud83d\udccb Modern dependency management (Poetry)\n</code></pre>"},{"location":"architecture/#concurrency-model","title":"Concurrency Model","text":"<p>When production dependencies are installed (<code>uvloop</code> group), TaipanStack bootstraps <code>uvloop</code> as the asyncio event loop, providing a 2\u20134\u00d7 throughput improvement over the standard <code>asyncio</code> loop on Linux/macOS.</p> <pre><code>from taipanstack.core.optimizations import apply_optimizations\n\napply_optimizations()  # Auto-installs uvloop + orjson if available\n</code></pre> <p>Python version detection is performed at import time via <code>taipanstack.core.compat</code>:</p> <pre><code>from taipanstack import PY313, get_features\n\nif PY313:\n    print(get_features())  # Reports 3.13-specific optimizations\n</code></pre>"},{"location":"architecture/#error-handling-philosophy","title":"Error Handling Philosophy","text":"<p>Exceptions represent unrecoverable panics. For standard, expected failures (network errors, validation failures, missing data), TaipanStack uses the <code>Result</code> monad:</p> <p>Rule: Never raise to communicate a business failure</p> <pre><code># \u274c DO NOT: leaks exception semantics into caller\ndef find_user(user_id: str) -&gt; User:\n    raise UserNotFoundError(...)\n\n# \u2705 DO: encode failure in the return type\ndef find_user(user_id: str) -&gt; Result[User, UserNotFoundError]:\n    return Err(UserNotFoundError(user_id))\n</code></pre> <p>Benefits enforced by Mypy strict:</p> <ul> <li>You cannot forget to handle an <code>Err</code> \u2014 the type checker forces it</li> <li>Pattern matching (<code>match</code>/<code>case</code>) gives exhaustive, safe unpacking</li> <li>The <code>@safe</code> decorator wraps any raising function into a <code>Result</code> automatically</li> </ul>"},{"location":"architecture/#security-strategy","title":"Security Strategy","text":"<p>TaipanStack's security layer is fail-closed by design:</p> Principle Implementation No silent failures Malformed input raises <code>SecurityError</code> or <code>TypeError</code> immediately Boundary validation All external data validated at entry via <code>pydantic</code> + guards Runtime type guards Every public security function validates input types at v0.3.1+ AST scanning Bandit + Semgrep (custom rules) runs on every CI push Supply chain SBOM (CycloneDX via Syft) + SLSA attestation (Cosign/Sigstore) on every release"},{"location":"api/config/","title":"Config \u2014 Models &amp; Generators","text":"<p>TaipanStack's configuration layer provides Pydantic v2 models, project scaffolding generators, and Python version-aware recommendations.</p>"},{"location":"api/config/#stackconfig-model","title":"StackConfig Model","text":"<p>Configuration models with Pydantic validation.</p> <p>This module provides type-safe configuration models that validate all inputs at runtime, preventing errors and AI hallucinations.</p>"},{"location":"api/config/#taipanstack.config.models.SecurityConfig","title":"SecurityConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Security-related configuration options.</p> ATTRIBUTE DESCRIPTION <code>level</code> <p>Security strictness level.</p> <p> TYPE: <code>Literal['standard', 'strict', 'paranoid']</code> </p> <code>enable_bandit</code> <p>Enable Bandit SAST scanner.</p> <p> TYPE: <code>bool</code> </p> <code>enable_safety</code> <p>Enable Safety dependency checker.</p> <p> TYPE: <code>bool</code> </p> <code>enable_semgrep</code> <p>Enable Semgrep analysis.</p> <p> TYPE: <code>bool</code> </p> <code>enable_detect_secrets</code> <p>Enable secret detection.</p> <p> TYPE: <code>bool</code> </p> <code>bandit_severity</code> <p>Minimum severity level for Bandit.</p> <p> TYPE: <code>Literal['low', 'medium', 'high']</code> </p>"},{"location":"api/config/#taipanstack.config.models.DependencyConfig","title":"DependencyConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dependency management configuration.</p> ATTRIBUTE DESCRIPTION <code>install_runtime_deps</code> <p>Install pydantic, orjson, uvloop.</p> <p> TYPE: <code>bool</code> </p> <code>install_dev_deps</code> <p>Install development dependencies.</p> <p> TYPE: <code>bool</code> </p> <code>dev_dependencies</code> <p>List of dev dependencies to install.</p> <p> TYPE: <code>list[str]</code> </p> <code>runtime_dependencies</code> <p>List of runtime dependencies to install.</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/config/#taipanstack.config.models.LoggingConfig","title":"LoggingConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Logging configuration options.</p> ATTRIBUTE DESCRIPTION <code>level</code> <p>Log level.</p> <p> TYPE: <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> </p> <code>format</code> <p>Log format type.</p> <p> TYPE: <code>Literal['simple', 'detailed', 'json']</code> </p> <code>enable_structured</code> <p>Use structured logging (JSON).</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/config/#taipanstack.config.models.StackConfig","title":"StackConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Main Stack configuration with full validation.</p> <p>This is the primary configuration model that validates all Stack settings at runtime, preventing configuration errors and catching AI hallucinations early.</p> ATTRIBUTE DESCRIPTION <code>project_name</code> <p>Name of the project (alphanumeric, _, -).</p> <p> TYPE: <code>str</code> </p> <code>python_version</code> <p>Target Python version (e.g., \"3.12\").</p> <p> TYPE: <code>str</code> </p> <code>project_dir</code> <p>Directory to initialize project in.</p> <p> TYPE: <code>Path</code> </p> <code>dry_run</code> <p>Simulate execution without changes.</p> <p> TYPE: <code>bool</code> </p> <code>force</code> <p>Overwrite existing files without backup.</p> <p> TYPE: <code>bool</code> </p> <code>verbose</code> <p>Enable verbose logging.</p> <p> TYPE: <code>bool</code> </p> <code>security</code> <p>Security configuration.</p> <p> TYPE: <code>SecurityConfig</code> </p> <code>dependencies</code> <p>Dependency configuration.</p> <p> TYPE: <code>DependencyConfig</code> </p> <code>logging</code> <p>Logging configuration.</p> <p> TYPE: <code>LoggingConfig</code> </p> Example <p>config = StackConfig( ...     project_name=\"my_project\", ...     python_version=\"3.12\", ... ) config.project_name 'my_project'</p>"},{"location":"api/config/#taipanstack.config.models.StackConfig.validate_project_name","title":"validate_project_name  <code>classmethod</code>","text":"<pre><code>validate_project_name(value: str) -&gt; str\n</code></pre> <p>Validate that project name is safe.</p> PARAMETER DESCRIPTION <code>value</code> <p>The project name to validate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated project name.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If project name contains invalid characters.</p> Source code in <code>src/taipanstack/config/models.py</code> <pre><code>@field_validator(\"project_name\")\n@classmethod\ndef validate_project_name(cls, value: str) -&gt; str:\n    \"\"\"Validate that project name is safe.\n\n    Args:\n        value: The project name to validate.\n\n    Returns:\n        The validated project name.\n\n    Raises:\n        ValueError: If project name contains invalid characters.\n\n    \"\"\"\n    pattern = r\"^[a-zA-Z][a-zA-Z0-9_-]*$\"\n    if not re.match(pattern, value):\n        msg = (\n            f\"Project name '{value}' is invalid. \"\n            \"Must start with a letter and contain only alphanumeric, \"\n            \"underscore, or hyphen characters.\"\n        )\n        raise ValueError(msg)\n    return value\n</code></pre>"},{"location":"api/config/#taipanstack.config.models.StackConfig.validate_python_version","title":"validate_python_version  <code>classmethod</code>","text":"<pre><code>validate_python_version(value: str) -&gt; str\n</code></pre> <p>Validate Python version format.</p> PARAMETER DESCRIPTION <code>value</code> <p>The Python version string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated Python version.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If version format is invalid.</p> Source code in <code>src/taipanstack/config/models.py</code> <pre><code>@field_validator(\"python_version\")\n@classmethod\ndef validate_python_version(cls, value: str) -&gt; str:\n    \"\"\"Validate Python version format.\n\n    Args:\n        value: The Python version string.\n\n    Returns:\n        The validated Python version.\n\n    Raises:\n        ValueError: If version format is invalid.\n\n    \"\"\"\n    pattern = r\"^\\d+\\.\\d+$\"\n    if not re.match(pattern, value):\n        msg = (\n            f\"Python version '{value}' is invalid. Use format 'X.Y' (e.g., '3.12').\"\n        )\n        raise ValueError(msg)\n\n    major, minor = map(int, value.split(\".\"))\n    is_old_python = major &lt; PYTHON_MAJOR_VERSION or (\n        major == PYTHON_MAJOR_VERSION and minor &lt; MIN_PYTHON_MINOR_VERSION\n    )\n    if is_old_python:\n        msg = (\n            f\"Python version {value} is not supported. \"\n            f\"Minimum is {PYTHON_MAJOR_VERSION}.{MIN_PYTHON_MINOR_VERSION}.\"\n        )\n        raise ValueError(msg)\n\n    return value\n</code></pre>"},{"location":"api/config/#taipanstack.config.models.StackConfig.validate_project_dir","title":"validate_project_dir  <code>classmethod</code>","text":"<pre><code>validate_project_dir(value: Path) -&gt; Path\n</code></pre> <p>Validate project directory is safe.</p> PARAMETER DESCRIPTION <code>value</code> <p>The project directory path.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>The validated and resolved path.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If path is unsafe or contains traversal.</p> Source code in <code>src/taipanstack/config/models.py</code> <pre><code>@field_validator(\"project_dir\")\n@classmethod\ndef validate_project_dir(cls, value: Path) -&gt; Path:\n    \"\"\"Validate project directory is safe.\n\n    Args:\n        value: The project directory path.\n\n    Returns:\n        The validated and resolved path.\n\n    Raises:\n        ValueError: If path is unsafe or contains traversal.\n\n    \"\"\"\n    resolved = value.resolve()\n\n    # Check for path traversal attempts\n    if \"..\" in str(value):\n        msg = f\"Path traversal detected in project_dir: {value}\"\n        raise ValueError(msg)\n\n    return resolved\n</code></pre>"},{"location":"api/config/#taipanstack.config.models.StackConfig.validate_config_consistency","title":"validate_config_consistency","text":"<pre><code>validate_config_consistency() -&gt; StackConfig\n</code></pre> <p>Validate configuration consistency.</p> RETURNS DESCRIPTION <code>StackConfig</code> <p>The validated configuration.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If configuration is inconsistent.</p> Source code in <code>src/taipanstack/config/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_config_consistency(self) -&gt; StackConfig:\n    \"\"\"Validate configuration consistency.\n\n    Returns:\n        The validated configuration.\n\n    Raises:\n        ValueError: If configuration is inconsistent.\n\n    \"\"\"\n    # If paranoid security, ensure all security tools are enabled\n    all_tools_enabled = all(\n        [\n            self.security.enable_bandit,\n            self.security.enable_safety,\n            self.security.enable_semgrep,\n            self.security.enable_detect_secrets,\n        ]\n    )\n    if self.security.level == \"paranoid\" and not all_tools_enabled:\n        msg = \"Paranoid security level requires all security tools enabled.\"\n        raise ValueError(msg)\n\n    return self\n</code></pre>"},{"location":"api/config/#taipanstack.config.models.StackConfig.to_target_version","title":"to_target_version","text":"<pre><code>to_target_version() -&gt; str\n</code></pre> <p>Get Python version in Ruff target format.</p> RETURNS DESCRIPTION <code>str</code> <p>Version string like 'py312'.</p> Source code in <code>src/taipanstack/config/models.py</code> <pre><code>def to_target_version(self) -&gt; str:\n    \"\"\"Get Python version in Ruff target format.\n\n    Returns:\n        Version string like 'py312'.\n\n    \"\"\"\n    return f\"py{self.python_version.replace('.', '')}\"\n</code></pre>"},{"location":"api/config/#version-config","title":"Version Config","text":"<p>Version-Specific Configuration Recommendations.</p> <p>This module provides configuration templates optimized for different Python versions, helping users get the best performance while maintaining stability.</p> <p>Following Stack pillars: Security, Stability, Simplicity, Scalability, Compatibility.</p>"},{"location":"api/config/#taipanstack.config.version_config.VersionRecommendations","title":"VersionRecommendations  <code>dataclass</code>","text":"<pre><code>VersionRecommendations(\n    version_tier: VersionTier,\n    min_version: str,\n    max_version: str | None,\n    recommended_thread_pool_size: int,\n    supports_true_parallelism: bool,\n    recommended_gc_mode: str,\n    use_mimalloc: bool,\n    use_type_params: bool,\n    use_exception_groups: bool,\n    use_match_statements: bool,\n    use_override_decorator: bool,\n    use_deprecated_decorator: bool,\n    jit_available: bool,\n    recommended_optimization_level: int,\n    notes: tuple[str, ...],\n)\n</code></pre> <p>Configuration recommendations for a Python version.</p> <p>These recommendations help users configure their Stack-based applications for optimal performance on their Python version.</p>"},{"location":"api/config/#taipanstack.config.version_config.VersionRecommendations.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, object]\n</code></pre> <p>Convert to dictionary for serialization.</p> Source code in <code>src/taipanstack/config/version_config.py</code> <pre><code>def to_dict(self) -&gt; dict[str, object]:\n    \"\"\"Convert to dictionary for serialization.\"\"\"\n    return {\n        \"version_tier\": self.version_tier.value,\n        \"version_range\": f\"{self.min_version} - {self.max_version or 'latest'}\",\n        \"threading\": {\n            \"pool_size\": self.recommended_thread_pool_size,\n            \"true_parallelism\": self.supports_true_parallelism,\n        },\n        \"memory\": {\n            \"gc_mode\": self.recommended_gc_mode,\n            \"mimalloc\": self.use_mimalloc,\n        },\n        \"code_style\": {\n            \"type_params\": self.use_type_params,\n            \"exception_groups\": self.use_exception_groups,\n            \"match_statements\": self.use_match_statements,\n            \"override_decorator\": self.use_override_decorator,\n            \"deprecated_decorator\": self.use_deprecated_decorator,\n        },\n        \"performance\": {\n            \"jit_available\": self.jit_available,\n            \"optimization_level\": self.recommended_optimization_level,\n        },\n        \"notes\": list(self.notes),\n    }\n</code></pre>"},{"location":"api/config/#taipanstack.config.version_config.get_version_recommendations","title":"get_version_recommendations","text":"<pre><code>get_version_recommendations() -&gt; VersionRecommendations\n</code></pre> <p>Get configuration recommendations for the current Python version.</p> RETURNS DESCRIPTION <code>VersionRecommendations</code> <p>VersionRecommendations with optimal settings.</p> Source code in <code>src/taipanstack/config/version_config.py</code> <pre><code>def get_version_recommendations() -&gt; VersionRecommendations:\n    \"\"\"Get configuration recommendations for the current Python version.\n\n    Returns:\n        VersionRecommendations with optimal settings.\n\n    \"\"\"\n    if PY314:\n        return _get_314_recommendations()\n    if PY313:\n        return _get_313_recommendations()\n    if PY312:\n        return _get_312_recommendations()\n    return _get_311_recommendations()\n</code></pre>"},{"location":"api/config/#generators","title":"Generators","text":"<p>Configuration file generators.</p> <p>This module generates configuration files (pyproject.toml, pre-commit, etc.) with proper validation and templating.</p>"},{"location":"api/config/#taipanstack.config.generators.generate_pyproject_config","title":"generate_pyproject_config","text":"<pre><code>generate_pyproject_config(config: StackConfig) -&gt; str\n</code></pre> <p>Generate Ruff, Mypy, and Pytest configuration for pyproject.toml.</p> PARAMETER DESCRIPTION <code>config</code> <p>The Stack configuration.</p> <p> TYPE: <code>StackConfig</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Configuration string to append to pyproject.toml.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def generate_pyproject_config(config: StackConfig) -&gt; str:\n    \"\"\"Generate Ruff, Mypy, and Pytest configuration for pyproject.toml.\n\n    Args:\n        config: The Stack configuration.\n\n    Returns:\n        Configuration string to append to pyproject.toml.\n\n    \"\"\"\n    target_version = config.to_target_version()\n    python_version = config.python_version\n\n    return f\"\"\"\n# --- Stack v2.0 Quality Configuration ---\n[tool.ruff]\nline-length = 88\ntarget-version = \"{target_version}\"\n\n[tool.ruff.lint]\nselect = [\n    \"F\",    # Pyflakes\n    \"E\",    # pycodestyle errors\n    \"W\",    # pycodestyle warnings\n    \"I\",    # isort\n    \"N\",    # pep8-naming\n    \"D\",    # pydocstyle\n    \"Q\",    # flake8-quotes\n    \"S\",    # flake8-bandit\n    \"B\",    # flake8-bugbear\n    \"A\",    # flake8-builtins\n    \"C4\",   # flake8-comprehensions\n    \"T20\",  # flake8-print\n    \"SIM\",  # flake8-simplify\n    \"PTH\",  # flake8-use-pathlib\n    \"TID\",  # flake8-tidy-imports\n    \"ARG\",  # flake8-unused-arguments\n    \"PIE\",  # flake8-pie\n    \"PLC\",  # Pylint Convention\n    \"PLE\",  # Pylint Error\n    \"PLR\",  # Pylint Refactor\n    \"PLW\",  # Pylint Warning\n    \"RUF\",  # Ruff-specific\n    \"UP\",   # pyupgrade\n    \"ERA\",  # eradicate\n    \"TRY\",  # tryceratops\n]\nignore = [\"D203\", \"D212\", \"D213\", \"D416\", \"D417\", \"B905\"]\n\n[tool.ruff.lint.mccabe]\nmax-complexity = 10\n\n[tool.ruff.lint.per-file-ignores]\n\"tests/**/*.py\" = [\"S101\", \"D\"]\n\n[tool.ruff.format]\nquote-style = \"double\"\nindent-style = \"space\"\n\n[tool.mypy]\npython_version = \"{python_version}\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ndisallow_any_unimported = false\nno_implicit_optional = true\ncheck_untyped_defs = true\nstrict_optional = true\nstrict_equality = true\nignore_missing_imports = true\nshow_error_codes = true\nenable_error_code = [\"ignore-without-code\", \"redundant-cast\", \"truthy-bool\"]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = \"-v --cov=src --cov-report=html --cov-report=term-missing --cov-fail-under=80 --strict-markers\"\nmarkers = [\n    \"slow: marks tests as slow (deselect with '-m \\\"not slow\\\"')\",\n    \"security: marks tests as security-related\",\n]\n\n[tool.coverage.run]\nbranch = true\nsource = [\"src\"]\nomit = [\"*/tests/*\", \"*/__pycache__/*\"]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise NotImplementedError\",\n    \"if TYPE_CHECKING:\",\n    \"if __name__ == .__main__.:\",\n]\n\"\"\"\n</code></pre>"},{"location":"api/config/#taipanstack.config.generators.generate_pre_commit_config","title":"generate_pre_commit_config","text":"<pre><code>generate_pre_commit_config(config: StackConfig) -&gt; str\n</code></pre> <p>Generate .pre-commit-config.yaml content.</p> PARAMETER DESCRIPTION <code>config</code> <p>The Stack configuration.</p> <p> TYPE: <code>StackConfig</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Pre-commit configuration YAML string.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def generate_pre_commit_config(config: StackConfig) -&gt; str:\n    \"\"\"Generate .pre-commit-config.yaml content.\n\n    Args:\n        config: The Stack configuration.\n\n    Returns:\n        Pre-commit configuration YAML string.\n\n    \"\"\"\n    security_hooks = \"\"\n\n    if config.security.enable_bandit:\n        severity = config.security.bandit_severity[0].upper()\n        security_hooks += f\"\"\"\n  - repo: https://github.com/PyCQA/bandit\n    rev: '1.8.0'\n    hooks:\n      - id: bandit\n        args: [\"-r\", \".\", \"-l{severity}\"]\n\"\"\"\n\n    if config.security.enable_safety:\n        security_hooks += \"\"\"\n  - repo: https://github.com/pyupio/safety\n    rev: '3.2.11'\n    hooks:\n      - id: safety\n        args: [\"check\", \"--json\"]\n\"\"\"\n\n    if config.security.enable_semgrep:\n        security_hooks += \"\"\"\n  - repo: https://github.com/semgrep/pre-commit\n    rev: 'v1.99.0'\n    hooks:\n      - id: semgrep\n        args: ['--config=auto']\n\"\"\"\n\n    if config.security.enable_detect_secrets:\n        security_hooks += \"\"\"\n  - repo: https://github.com/Yelp/detect-secrets\n    rev: 'v1.5.0'\n    hooks:\n      - id: detect-secrets\n        args: ['--baseline', '.secrets.baseline']\n\"\"\"\n\n    # Add pip-audit for paranoid mode\n    if config.security.level == \"paranoid\":\n        security_hooks += \"\"\"\n  - repo: https://github.com/trailofbits/pip-audit\n    rev: 'v2.7.3'\n    hooks:\n      - id: pip-audit\n\n  - repo: https://github.com/jendrikseipp/vulture\n    rev: 'v2.11'\n    hooks:\n      - id: vulture\n\n  - repo: https://github.com/guilatrova/tryceratops\n    rev: 'v2.3.3'\n    hooks:\n      - id: tryceratops\n\"\"\"\n\n    return f\"\"\"# Stack v2.0 Pre-commit Configuration\n# Security Level: {config.security.level}\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n      - id: check-merge-conflict\n      - id: check-case-conflict\n      - id: detect-private-key\n\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: 'v0.8.4'\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n      - id: ruff-format\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: 'v1.13.0'\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all, pydantic]\n{security_hooks}\"\"\"\n</code></pre>"},{"location":"api/config/#taipanstack.config.generators.generate_dependabot_config","title":"generate_dependabot_config","text":"<pre><code>generate_dependabot_config() -&gt; str\n</code></pre> <p>Generate .github/dependabot.yml content.</p> RETURNS DESCRIPTION <code>str</code> <p>Dependabot configuration YAML string.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def generate_dependabot_config() -&gt; str:\n    \"\"\"Generate .github/dependabot.yml content.\n\n    Returns:\n        Dependabot configuration YAML string.\n\n    \"\"\"\n    return \"\"\"# Stack v2.0 Dependabot Configuration\nversion: 2\nupdates:\n  - package-ecosystem: \"pip\"\n    directory: \"/\"\n    schedule:\n      interval: \"daily\"\n    open-pull-requests-limit: 10\n    groups:\n      dev-dependencies:\n        patterns:\n          - \"ruff\"\n          - \"mypy\"\n          - \"bandit\"\n          - \"safety\"\n          - \"pytest*\"\n          - \"pre-commit\"\n          - \"semgrep\"\n          - \"py-spy\"\n      security-tools:\n        patterns:\n          - \"bandit\"\n          - \"safety\"\n          - \"semgrep\"\n          - \"pip-audit\"\n    reviewers:\n      - \"gabrielima7\"\n\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    groups:\n      actions:\n        patterns:\n          - \"*\"\n\"\"\"\n</code></pre>"},{"location":"api/config/#taipanstack.config.generators.generate_security_policy","title":"generate_security_policy","text":"<pre><code>generate_security_policy() -&gt; str\n</code></pre> <p>Generate SECURITY.md content.</p> RETURNS DESCRIPTION <code>str</code> <p>Security policy markdown string.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def generate_security_policy() -&gt; str:\n    \"\"\"Generate SECURITY.md content.\n\n    Returns:\n        Security policy markdown string.\n\n    \"\"\"\n    return \"\"\"# Security Policy\n\n## Supported Versions\n\nWe prioritize security fixes for the latest version (Rolling Release).\n\n| Version | Supported          |\n| ------- | ------------------ |\n| Latest  | :white_check_mark: |\n| Older   | :x:                |\n\n## Security Features\n\nThis project includes multiple layers of security:\n\n- **SAST**: Bandit for static security analysis\n- **SCA**: Safety/pip-audit for dependency vulnerabilities\n- **Secrets**: detect-secrets for preventing credential leaks\n- **Type Safety**: Mypy + Pydantic for runtime validation\n- **Runtime Guards**: Protection against path traversal and injection\n\n## Reporting a Vulnerability\n\n1. **DO NOT** create a public issue for security vulnerabilities\n2. Report via the [Security tab](../../security/advisories/new)\n3. Or email the maintainer directly\n4. Include:\n   - Description of the vulnerability\n   - Steps to reproduce\n   - Potential impact\n   - Suggested fix (if any)\n\n## Response Timeline\n\n- **Acknowledgment**: Within 48 hours\n- **Initial Assessment**: Within 1 week\n- **Fix Release**: Depends on severity (critical: ASAP, others: next release)\n\"\"\"\n</code></pre>"},{"location":"api/config/#taipanstack.config.generators.generate_editorconfig","title":"generate_editorconfig","text":"<pre><code>generate_editorconfig() -&gt; str\n</code></pre> <p>Generate .editorconfig content.</p> RETURNS DESCRIPTION <code>str</code> <p>EditorConfig content string.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def generate_editorconfig() -&gt; str:\n    \"\"\"Generate .editorconfig content.\n\n    Returns:\n        EditorConfig content string.\n\n    \"\"\"\n    return \"\"\"# Stack v2.0 EditorConfig\nroot = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\ncharset = utf-8\nindent_style = space\nindent_size = 4\n\n[*.py]\nmax_line_length = 88\n\n[*.{yml,yaml,toml,json}]\nindent_size = 2\n\n[Makefile]\nindent_style = tab\n\"\"\"\n</code></pre>"},{"location":"api/config/#taipanstack.config.generators.write_config_file","title":"write_config_file","text":"<pre><code>write_config_file(\n    path: Path, content: str, config: StackConfig\n) -&gt; bool\n</code></pre> <p>Write configuration file with backup support.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to write the file.</p> <p> TYPE: <code>Path</code> </p> <code>content</code> <p>Content to write.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Stack configuration.</p> <p> TYPE: <code>StackConfig</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if file was written, False if in dry-run mode.</p> Source code in <code>src/taipanstack/config/generators.py</code> <pre><code>def write_config_file(\n    path: Path,\n    content: str,\n    config: StackConfig,\n) -&gt; bool:\n    \"\"\"Write configuration file with backup support.\n\n    Args:\n        path: Path to write the file.\n        content: Content to write.\n        config: Stack configuration.\n\n    Returns:\n        True if file was written, False if in dry-run mode.\n\n    \"\"\"\n    if config.dry_run:\n        return False\n\n    if path.exists() and not config.force:\n        backup_path = path.with_suffix(f\"{path.suffix}.bak\")\n        path.rename(backup_path)\n\n    path.write_text(content, encoding=\"utf-8\")\n    return True\n</code></pre>"},{"location":"api/core/","title":"Core \u2014 Result Types","text":"<p>TaipanStack's core module provides Rust-inspired <code>Result</code> types for explicit, type-safe error handling.</p>"},{"location":"api/core/#taipanstackcoreresult","title":"<code>taipanstack.core.result</code>","text":"<p>Result type utilities for functional error handling.</p> <p>Provides Rust-style Result types (Ok/Err) for explicit error handling, avoiding exceptions for expected failure cases. This promotes safer, more predictable code.</p> Example <p>from taipanstack.core.result import safe, Ok, Err @safe ... def divide(a: int, b: int) -&gt; float: ...     if b == 0: ...         raise ValueError(\"division by zero\") ...     return a / b result = divide(10, 0) match result: ...     case Err(e): ...         print(f\"Error: {e}\") ...     case Ok(value): ...         print(f\"Result: {value}\") Error: division by zero</p>"},{"location":"api/core/#taipanstack.core.result.safe","title":"safe","text":"<pre><code>safe(\n    func: Callable[P, T],\n) -&gt; Callable[P, Result[T, Exception]]\n</code></pre> <p>Decorator to convert exceptions into Err results.</p> <p>Wraps a function so that any exception raised becomes an Err, while successful returns become Ok.</p> PARAMETER DESCRIPTION <code>func</code> <p>The function to wrap.</p> <p> TYPE: <code>Callable[P, T]</code> </p> RETURNS DESCRIPTION <code>Callable[P, Result[T, Exception]]</code> <p>A wrapped function that returns Result[T, Exception].</p> Example <p>@safe ... def parse_int(s: str) -&gt; int: ...     return int(s) parse_int(\"42\") Ok(42) parse_int(\"invalid\") Err(ValueError(\"invalid literal for int()...\"))</p> Source code in <code>src/taipanstack/core/result.py</code> <pre><code>def safe(\n    func: Callable[P, T],\n) -&gt; Callable[P, Result[T, Exception]]:\n    \"\"\"Decorator to convert exceptions into Err results.\n\n    Wraps a function so that any exception raised becomes an Err,\n    while successful returns become Ok.\n\n    Args:\n        func: The function to wrap.\n\n    Returns:\n        A wrapped function that returns Result[T, Exception].\n\n    Example:\n        &gt;&gt;&gt; @safe\n        ... def parse_int(s: str) -&gt; int:\n        ...     return int(s)\n        &gt;&gt;&gt; parse_int(\"42\")\n        Ok(42)\n        &gt;&gt;&gt; parse_int(\"invalid\")\n        Err(ValueError(\"invalid literal for int()...\"))\n\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, Exception]:\n        try:\n            return Ok(func(*args, **kwargs))\n        except Exception as e:\n            return Err(e)\n\n    return wrapper\n</code></pre>"},{"location":"api/core/#taipanstack.core.result.safe_from","title":"safe_from","text":"<pre><code>safe_from(\n    *exception_types: type[E],\n) -&gt; Callable[\n    [Callable[P, T]], Callable[P, Result[T, E]]\n]\n</code></pre> <p>Decorator factory to catch specific exceptions as Err.</p> <p>Only catches specified exception types; others propagate normally.</p> PARAMETER DESCRIPTION <code>*exception_types</code> <p>Exception types to convert to Err.</p> <p> TYPE: <code>type[E]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, T]], Callable[P, Result[T, E]]]</code> <p>Decorator that wraps function with selective error handling.</p> Example <p>@safe_from(ValueError, TypeError) ... def process(data: str) -&gt; int: ...     return int(data) process(\"abc\") Err(ValueError(...))</p> Source code in <code>src/taipanstack/core/result.py</code> <pre><code>def safe_from(\n    *exception_types: type[E],\n) -&gt; Callable[[Callable[P, T]], Callable[P, Result[T, E]]]:\n    \"\"\"Decorator factory to catch specific exceptions as Err.\n\n    Only catches specified exception types; others propagate normally.\n\n    Args:\n        *exception_types: Exception types to convert to Err.\n\n    Returns:\n        Decorator that wraps function with selective error handling.\n\n    Example:\n        &gt;&gt;&gt; @safe_from(ValueError, TypeError)\n        ... def process(data: str) -&gt; int:\n        ...     return int(data)\n        &gt;&gt;&gt; process(\"abc\")\n        Err(ValueError(...))\n\n    \"\"\"\n\n    def decorator(func: Callable[P, T]) -&gt; Callable[P, Result[T, E]]:\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, E]:\n            try:\n                return Ok(func(*args, **kwargs))\n            except exception_types as e:\n                return Err(e)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/core/#taipanstack.core.result.collect_results","title":"collect_results","text":"<pre><code>collect_results(\n    results: Iterable[Result[T, E]],\n) -&gt; Result[list[T], E]\n</code></pre> <p>Collect an iterable of Results into a single Result.</p> <p>If all results are Ok, returns Ok with list of values. If any result is Err, returns the first Err encountered.</p> PARAMETER DESCRIPTION <code>results</code> <p>Iterable of Result objects.</p> <p> TYPE: <code>Iterable[Result[T, E]]</code> </p> RETURNS DESCRIPTION <code>Result[list[T], E]</code> <p>Ok(list[T]) if all are Ok, otherwise first Err.</p> Example <p>collect_results([Ok(1), Ok(2), Ok(3)]) Ok([1, 2, 3]) collect_results([Ok(1), Err(\"fail\"), Ok(3)]) Err(\"fail\")</p> Source code in <code>src/taipanstack/core/result.py</code> <pre><code>def collect_results(\n    results: Iterable[Result[T, E]],\n) -&gt; Result[list[T], E]:\n    \"\"\"Collect an iterable of Results into a single Result.\n\n    If all results are Ok, returns Ok with list of values.\n    If any result is Err, returns the first Err encountered.\n\n    Args:\n        results: Iterable of Result objects.\n\n    Returns:\n        Ok(list[T]) if all are Ok, otherwise first Err.\n\n    Example:\n        &gt;&gt;&gt; collect_results([Ok(1), Ok(2), Ok(3)])\n        Ok([1, 2, 3])\n        &gt;&gt;&gt; collect_results([Ok(1), Err(\"fail\"), Ok(3)])\n        Err(\"fail\")\n\n    \"\"\"\n    values: list[T] = []\n    for result in results:\n        match result:\n            case Ok(value):\n                values.append(value)\n            case Err() as err:\n                return err\n    return Ok(values)\n</code></pre>"},{"location":"api/core/#taipanstack.core.result.unwrap_or","title":"unwrap_or","text":"<pre><code>unwrap_or(result: Ok[T], default: U) -&gt; T\n</code></pre><pre><code>unwrap_or(result: Err[E], default: U) -&gt; U\n</code></pre><pre><code>unwrap_or(result: Result[T, E], default: U) -&gt; T | U\n</code></pre> <pre><code>unwrap_or(result: Result[T, E], default: U) -&gt; T | U\n</code></pre> <p>Extract value from Result or return default.</p> PARAMETER DESCRIPTION <code>result</code> <p>The Result to unwrap.</p> <p> TYPE: <code>Result[T, E]</code> </p> <code>default</code> <p>Default value if result is Err.</p> <p> TYPE: <code>U</code> </p> RETURNS DESCRIPTION <code>T | U</code> <p>The Ok value or the default.</p> Example <p>unwrap_or(Ok(42), 0) 42 unwrap_or(Err(\"error\"), 0) 0</p> Source code in <code>src/taipanstack/core/result.py</code> <pre><code>def unwrap_or(result: Result[T, E], default: U) -&gt; T | U:\n    \"\"\"Extract value from Result or return default.\n\n    Args:\n        result: The Result to unwrap.\n        default: Default value if result is Err.\n\n    Returns:\n        The Ok value or the default.\n\n    Example:\n        &gt;&gt;&gt; unwrap_or(Ok(42), 0)\n        42\n        &gt;&gt;&gt; unwrap_or(Err(\"error\"), 0)\n        0\n\n    \"\"\"\n    match result:\n        case Ok(value):\n            return value\n        case Err():\n            return default\n</code></pre>"},{"location":"api/core/#taipanstack.core.result.unwrap_or_else","title":"unwrap_or_else","text":"<pre><code>unwrap_or_else(\n    result: Ok[T], default_fn: Callable[[E], U]\n) -&gt; T\n</code></pre><pre><code>unwrap_or_else(\n    result: Err[E], default_fn: Callable[[E], U]\n) -&gt; U\n</code></pre><pre><code>unwrap_or_else(\n    result: Result[T, E], default_fn: Callable[[E], U]\n) -&gt; T | U\n</code></pre> <pre><code>unwrap_or_else(\n    result: Result[T, E], default_fn: Callable[[E], U]\n) -&gt; T | U\n</code></pre> <p>Extract value from Result or compute default from error.</p> PARAMETER DESCRIPTION <code>result</code> <p>The Result to unwrap.</p> <p> TYPE: <code>Result[T, E]</code> </p> <code>default_fn</code> <p>Function to compute default from error.</p> <p> TYPE: <code>Callable[[E], U]</code> </p> RETURNS DESCRIPTION <code>T | U</code> <p>The Ok value or computed default.</p> Example <p>unwrap_or_else(Ok(42), lambda e: 0) 42 unwrap_or_else(Err(ValueError(\"x\")), lambda e: len(str(e))) 1</p> Source code in <code>src/taipanstack/core/result.py</code> <pre><code>def unwrap_or_else(\n    result: Result[T, E],\n    default_fn: Callable[[E], U],\n) -&gt; T | U:\n    \"\"\"Extract value from Result or compute default from error.\n\n    Args:\n        result: The Result to unwrap.\n        default_fn: Function to compute default from error.\n\n    Returns:\n        The Ok value or computed default.\n\n    Example:\n        &gt;&gt;&gt; unwrap_or_else(Ok(42), lambda e: 0)\n        42\n        &gt;&gt;&gt; unwrap_or_else(Err(ValueError(\"x\")), lambda e: len(str(e)))\n        1\n\n    \"\"\"\n    match result:\n        case Ok(value):\n            return value\n        case Err(error):\n            return default_fn(error)\n</code></pre>"},{"location":"api/security/","title":"Security \u2014 Guards, Sanitizers &amp; Validators","text":"<p>TaipanStack's security layer provides input validation, sanitization, and security guards to prevent common attack vectors.</p>"},{"location":"api/security/#guards","title":"Guards","text":"<p>Runtime guards for protection against errors and AI hallucinations.</p> <p>These guards provide runtime protection against common security issues and programming errors that can occur from incorrect AI-generated code. All guards raise SecurityError on violation.</p>"},{"location":"api/security/#taipanstack.security.guards.SecurityError","title":"SecurityError","text":"<pre><code>SecurityError(\n    message: str,\n    guard_name: str = \"unknown\",\n    value: str | None = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when a security guard detects a violation.</p> ATTRIBUTE DESCRIPTION <code>guard_name</code> <p>Name of the guard that was triggered.</p> <p> </p> <code>message</code> <p>Description of the violation.</p> <p> </p> <code>value</code> <p>The offending value (if safe to log).</p> <p> </p> <p>Initialize SecurityError.</p> PARAMETER DESCRIPTION <code>message</code> <p>Description of the violation.</p> <p> TYPE: <code>str</code> </p> <code>guard_name</code> <p>Name of the guard that triggered.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'unknown'</code> </p> <code>value</code> <p>The offending value (sanitized).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/taipanstack/security/guards.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    guard_name: str = \"unknown\",\n    value: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize SecurityError.\n\n    Args:\n        message: Description of the violation.\n        guard_name: Name of the guard that triggered.\n        value: The offending value (sanitized).\n\n    \"\"\"\n    self.guard_name = guard_name\n    self.value = value\n    super().__init__(f\"[{guard_name}] {message}\")\n</code></pre>"},{"location":"api/security/#taipanstack.security.guards.guard_path_traversal","title":"guard_path_traversal","text":"<pre><code>guard_path_traversal(\n    path: Path | str,\n    base_dir: Path | str | None = None,\n    *,\n    allow_symlinks: bool = False,\n) -&gt; Path\n</code></pre> <p>Prevent path traversal attacks.</p> <p>Ensures that the given path does not escape the base directory using techniques like '..' or symlinks.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to validate.</p> <p> TYPE: <code>Path | str</code> </p> <code>base_dir</code> <p>The base directory to constrain to. Defaults to cwd.</p> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>allow_symlinks</code> <p>Whether to allow symlinks (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>The resolved, validated path.</p> RAISES DESCRIPTION <code>SecurityError</code> <p>If path traversal is detected.</p> Example <p>guard_path_traversal(\"../etc/passwd\", Path(\"/app\")) SecurityError: [path_traversal] Path escapes base directory</p> Source code in <code>src/taipanstack/security/guards.py</code> <pre><code>def guard_path_traversal(\n    path: Path | str,\n    base_dir: Path | str | None = None,\n    *,\n    allow_symlinks: bool = False,\n) -&gt; Path:\n    \"\"\"Prevent path traversal attacks.\n\n    Ensures that the given path does not escape the base directory\n    using techniques like '..' or symlinks.\n\n    Args:\n        path: The path to validate.\n        base_dir: The base directory to constrain to. Defaults to cwd.\n        allow_symlinks: Whether to allow symlinks (default: False).\n\n    Returns:\n        The resolved, validated path.\n\n    Raises:\n        SecurityError: If path traversal is detected.\n\n    Example:\n        &gt;&gt;&gt; guard_path_traversal(\"../etc/passwd\", Path(\"/app\"))\n        SecurityError: [path_traversal] Path escapes base directory\n\n    \"\"\"\n    if not isinstance(path, (str, Path)):\n        raise TypeError(f\"path must be str or Path, got {type(path).__name__}\")\n    path = Path(path) if isinstance(path, str) else path\n    base_dir = Path(base_dir).resolve() if base_dir else Path.cwd().resolve()\n\n    # Check for explicit traversal patterns before resolution\n    path_str = str(path)\n    traversal_patterns = [\n        \"..\",\n        \"~\",\n        r\"\\.\\.\",\n        \"%2e%2e\",  # URL encoded ..\n        \"%252e%252e\",  # Double URL encoded\n    ]\n\n    for pattern in traversal_patterns:\n        if pattern.lower() in path_str.lower():\n            raise SecurityError(\n                f\"Path traversal pattern detected: {pattern}\",\n                guard_name=\"path_traversal\",\n                value=path_str[:50],  # Truncate for safety\n            )\n\n    # Resolve the path\n    try:\n        resolved = path.resolve() if path.is_absolute() else (base_dir / path).resolve()\n    except (OSError, ValueError) as e:\n        raise SecurityError(\n            f\"Invalid path: {e}\",\n            guard_name=\"path_traversal\",\n        ) from e\n\n    # Check if resolved path is within base_dir\n    try:\n        resolved.relative_to(base_dir)\n    except ValueError as e:\n        raise SecurityError(\n            f\"Path escapes base directory: {resolved} is not under {base_dir}\",\n            guard_name=\"path_traversal\",\n            value=str(resolved)[:100],\n        ) from e\n\n    # Check for symlinks if not allowed\n    is_existing_symlink = (\n        not allow_symlinks and resolved.exists() and resolved.is_symlink()\n    )\n    if is_existing_symlink:\n        raise SecurityError(\n            \"Symlinks are not allowed\",\n            guard_name=\"path_traversal\",\n            value=str(resolved),\n        )\n\n    return resolved\n</code></pre>"},{"location":"api/security/#taipanstack.security.guards.guard_command_injection","title":"guard_command_injection","text":"<pre><code>guard_command_injection(\n    command: Sequence[str],\n    *,\n    allowed_commands: Sequence[str] | None = None,\n) -&gt; list[str]\n</code></pre> <p>Prevent command injection attacks.</p> <p>Validates that command arguments don't contain shell metacharacters that could lead to command injection.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command and arguments as a sequence.</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>allowed_commands</code> <p>Optional whitelist of allowed base commands.</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The validated command as a list.</p> RAISES DESCRIPTION <code>SecurityError</code> <p>If command injection is detected.</p> Example <p>guard_command_injection([\"echo\", \"hello; rm -rf /\"]) SecurityError: [command_injection] Dangerous characters detected</p> Source code in <code>src/taipanstack/security/guards.py</code> <pre><code>def guard_command_injection(\n    command: Sequence[str],\n    *,\n    allowed_commands: Sequence[str] | None = None,\n) -&gt; list[str]:\n    \"\"\"Prevent command injection attacks.\n\n    Validates that command arguments don't contain shell metacharacters\n    that could lead to command injection.\n\n    Args:\n        command: The command and arguments as a sequence.\n        allowed_commands: Optional whitelist of allowed base commands.\n\n    Returns:\n        The validated command as a list.\n\n    Raises:\n        SecurityError: If command injection is detected.\n\n    Example:\n        &gt;&gt;&gt; guard_command_injection([\"echo\", \"hello; rm -rf /\"])\n        SecurityError: [command_injection] Dangerous characters detected\n\n    \"\"\"\n    if not command:\n        raise SecurityError(\n            \"Empty command is not allowed\",\n            guard_name=\"command_injection\",\n        )\n\n    cmd_list = list(command)\n\n    # Validate all items are strings\n    for i, arg in enumerate(cmd_list):\n        if not isinstance(arg, str):\n            raise TypeError(\n                f\"All command arguments must be strings, \"\n                f\"got {type(arg).__name__} at index {i}\"\n            )\n\n    # Dangerous shell metacharacters\n    dangerous_patterns: list[tuple[str, str]] = [\n        (\";\", \"command separator\"),\n        (\"|\", \"pipe\"),\n        (\"&amp;\", \"background/and operator\"),\n        (\"$\", \"variable expansion\"),\n        (\"`\", \"command substitution\"),\n        (\"$(\", \"command substitution\"),\n        (\"${\", \"variable expansion\"),\n        (\"&gt;\", \"redirect\"),\n        (\"&lt;\", \"redirect\"),\n        (\"&gt;&gt;\", \"redirect append\"),\n        (\"||\", \"or operator\"),\n        (\"&amp;&amp;\", \"and operator\"),\n        (\"\\n\", \"newline\"),\n        (\"\\r\", \"carriage return\"),\n        (\"\\x00\", \"null byte\"),\n    ]\n\n    for arg in cmd_list:\n        for pattern, description in dangerous_patterns:\n            if pattern in arg:\n                raise SecurityError(\n                    f\"Dangerous shell character detected: {description}\",\n                    guard_name=\"command_injection\",\n                    value=arg[:50],\n                )\n\n    # Check against allowed commands whitelist\n    if allowed_commands is not None:\n        base_command = cmd_list[0]\n        # Get just the command name without path\n        command_name = Path(base_command).name\n        cmd_not_allowed = (\n            command_name not in allowed_commands\n            and base_command not in allowed_commands\n        )\n        if cmd_not_allowed:\n            raise SecurityError(\n                f\"Command not in allowed list: {command_name}\",\n                guard_name=\"command_injection\",\n                value=command_name,\n            )\n\n    return cmd_list\n</code></pre>"},{"location":"api/security/#taipanstack.security.guards.guard_file_extension","title":"guard_file_extension","text":"<pre><code>guard_file_extension(\n    filename: str | Path,\n    *,\n    allowed_extensions: Sequence[str] | None = None,\n    denied_extensions: Sequence[str] | None = None,\n) -&gt; Path\n</code></pre> <p>Validate file extension against allow/deny lists.</p> PARAMETER DESCRIPTION <code>filename</code> <p>The filename to check.</p> <p> TYPE: <code>str | Path</code> </p> <code>allowed_extensions</code> <p>Extensions to allow (with or without dot).</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>denied_extensions</code> <p>Extensions to deny (with or without dot).</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>The filename as a Path.</p> RAISES DESCRIPTION <code>SecurityError</code> <p>If extension is not allowed or is denied.</p> Source code in <code>src/taipanstack/security/guards.py</code> <pre><code>def guard_file_extension(\n    filename: str | Path,\n    *,\n    allowed_extensions: Sequence[str] | None = None,\n    denied_extensions: Sequence[str] | None = None,\n) -&gt; Path:\n    \"\"\"Validate file extension against allow/deny lists.\n\n    Args:\n        filename: The filename to check.\n        allowed_extensions: Extensions to allow (with or without dot).\n        denied_extensions: Extensions to deny (with or without dot).\n\n    Returns:\n        The filename as a Path.\n\n    Raises:\n        SecurityError: If extension is not allowed or is denied.\n\n    \"\"\"\n    path = Path(filename)\n    ext = path.suffix.lower().lstrip(\".\")\n\n    # Default dangerous extensions\n    default_denied = {\n        \"exe\",\n        \"dll\",\n        \"so\",\n        \"dylib\",  # Executables\n        \"sh\",\n        \"bash\",\n        \"zsh\",\n        \"ps1\",\n        \"bat\",\n        \"cmd\",  # Scripts\n        \"php\",\n        \"jsp\",\n        \"asp\",\n        \"aspx\",  # Server-side scripts\n    }\n\n    # Normalize extension lists\n    def normalize_ext(e: str) -&gt; str:\n        return e.lower().lstrip(\".\")\n\n    if denied_extensions is not None:\n        denied = {normalize_ext(e) for e in denied_extensions}\n    else:\n        denied = default_denied\n\n    if ext in denied:\n        raise SecurityError(\n            f\"File extension '{ext}' is not allowed\",\n            guard_name=\"file_extension\",\n            value=str(path.name),\n        )\n\n    if allowed_extensions is not None:  # pragma: no branch\n        allowed = {normalize_ext(e) for e in allowed_extensions}\n        if ext not in allowed:\n            raise SecurityError(\n                f\"File extension '{ext}' is not in allowed list\",\n                guard_name=\"file_extension\",\n                value=str(path.name),\n            )\n\n    return path\n</code></pre>"},{"location":"api/security/#taipanstack.security.guards.guard_env_variable","title":"guard_env_variable","text":"<pre><code>guard_env_variable(\n    name: str,\n    *,\n    allowed_names: Sequence[str] | None = None,\n    denied_names: Sequence[str] | None = None,\n) -&gt; str\n</code></pre> <p>Guard against accessing sensitive environment variables.</p> PARAMETER DESCRIPTION <code>name</code> <p>The environment variable name.</p> <p> TYPE: <code>str</code> </p> <code>allowed_names</code> <p>Variable names to allow.</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>denied_names</code> <p>Variable names to deny.</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The environment variable value if safe.</p> RAISES DESCRIPTION <code>SecurityError</code> <p>If variable access is not allowed.</p> Source code in <code>src/taipanstack/security/guards.py</code> <pre><code>def guard_env_variable(\n    name: str,\n    *,\n    allowed_names: Sequence[str] | None = None,\n    denied_names: Sequence[str] | None = None,\n) -&gt; str:\n    \"\"\"Guard against accessing sensitive environment variables.\n\n    Args:\n        name: The environment variable name.\n        allowed_names: Variable names to allow.\n        denied_names: Variable names to deny.\n\n    Returns:\n        The environment variable value if safe.\n\n    Raises:\n        SecurityError: If variable access is not allowed.\n\n    \"\"\"\n    # Default sensitive variables\n    default_denied = {\n        \"AWS_SECRET_ACCESS_KEY\",\n        \"AWS_SESSION_TOKEN\",\n        \"GITHUB_TOKEN\",\n        \"GH_TOKEN\",\n        \"GITLAB_TOKEN\",\n        \"DATABASE_URL\",\n        \"DB_PASSWORD\",\n        \"PASSWORD\",\n        \"SECRET_KEY\",\n        \"PRIVATE_KEY\",\n        \"API_KEY\",\n        \"API_SECRET\",\n    }\n\n    # Validate input type\n    if not isinstance(name, str):\n        raise TypeError(f\"Variable name must be str, got {type(name).__name__}\")\n\n    # Reject empty/whitespace-only variable names\n    if not name or not name.strip():\n        raise SecurityError(\n            \"Environment variable name cannot be empty or whitespace\",\n            guard_name=\"env_variable\",\n        )\n\n    name_upper = name.upper()\n\n    if denied_names is not None:\n        denied = {n.upper() for n in denied_names}\n    else:\n        denied = default_denied\n\n    # Check against patterns\n    sensitive_patterns = [\n        r\".*SECRET.*\",\n        r\".*PASSWORD.*\",\n        r\".*TOKEN.*\",\n        r\".*PRIVATE.*KEY.*\",\n        r\".*API.*KEY.*\",\n    ]\n\n    if name_upper in denied:\n        raise SecurityError(\n            f\"Access to sensitive variable '{name}' is denied\",\n            guard_name=\"env_variable\",\n            value=name,\n        )\n\n    for pattern in sensitive_patterns:\n        if re.match(pattern, name_upper):\n            # Only block if not explicitly allowed\n            if allowed_names is not None:\n                allowed = {n.upper() for n in allowed_names}\n                if name_upper not in allowed:\n                    raise SecurityError(\n                        f\"Access to potentially sensitive variable '{name}' is denied\",\n                        guard_name=\"env_variable\",\n                        value=name,\n                    )\n            else:\n                raise SecurityError(\n                    f\"Access to potentially sensitive variable '{name}' is denied\",\n                    guard_name=\"env_variable\",\n                    value=name,\n                )\n\n    # Get the variable\n    value = os.environ.get(name)\n    if value is None:\n        raise SecurityError(\n            f\"Environment variable '{name}' is not set\",\n            guard_name=\"env_variable\",\n            value=name,\n        )\n\n    return value\n</code></pre>"},{"location":"api/security/#sanitizers","title":"Sanitizers","text":"<p>Input sanitizers for cleaning untrusted data.</p> <p>Provides functions to sanitize strings, filenames, and paths to remove potentially dangerous characters.</p>"},{"location":"api/security/#taipanstack.security.sanitizers.sanitize_string","title":"sanitize_string","text":"<pre><code>sanitize_string(\n    value: str,\n    *,\n    max_length: int | None = None,\n    allow_html: bool = False,\n    allow_unicode: bool = True,\n    strip_whitespace: bool = True,\n) -&gt; str\n</code></pre> <p>Sanitize a string by removing dangerous characters.</p> PARAMETER DESCRIPTION <code>value</code> <p>The string to sanitize.</p> <p> TYPE: <code>str</code> </p> <code>max_length</code> <p>Maximum length to truncate to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>allow_html</code> <p>Whether to keep HTML tags (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>allow_unicode</code> <p>Whether to keep non-ASCII characters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strip_whitespace</code> <p>Whether to strip leading/trailing whitespace.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The sanitized string.</p> Example <p>sanitize_string(\"Hello\") \"scriptalert('xss')/scriptHello\"</p> Source code in <code>src/taipanstack/security/sanitizers.py</code> <pre><code>def sanitize_string(\n    value: str,\n    *,\n    max_length: int | None = None,\n    allow_html: bool = False,\n    allow_unicode: bool = True,\n    strip_whitespace: bool = True,\n) -&gt; str:\n    \"\"\"Sanitize a string by removing dangerous characters.\n\n    Args:\n        value: The string to sanitize.\n        max_length: Maximum length to truncate to.\n        allow_html: Whether to keep HTML tags (default: False).\n        allow_unicode: Whether to keep non-ASCII characters.\n        strip_whitespace: Whether to strip leading/trailing whitespace.\n\n    Returns:\n        The sanitized string.\n\n    Example:\n        &gt;&gt;&gt; sanitize_string(\"&lt;script&gt;alert('xss')&lt;/script&gt;Hello\")\n        \"scriptalert('xss')/scriptHello\"\n\n    \"\"\"\n    if not isinstance(value, str):\n        raise TypeError(f\"value must be str, got {type(value).__name__}\")\n\n    if not value:\n        return \"\"\n\n    result = value\n\n    # Strip whitespace first\n    if strip_whitespace:\n        result = result.strip()\n\n    # Remove null bytes and control characters\n    result = result.replace(\"\\x00\", \"\")\n    result = \"\".join(\n        c for c in result if unicodedata.category(c) != \"Cc\" or c in \"\\n\\r\\t\"\n    )\n\n    # Handle HTML\n    if not allow_html:\n        # Remove HTML tags\n        result = re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", result)\n        # Escape HTML entities\n        result = result.replace(\"&amp;\", \"&amp;amp;\")\n        result = result.replace(\"&lt;\", \"&amp;lt;\")\n        result = result.replace(\"&gt;\", \"&amp;gt;\")\n\n    # Handle unicode\n    if not allow_unicode:\n        result = result.encode(\"ascii\", errors=\"ignore\").decode(\"ascii\")\n\n    # Truncate if needed\n    if max_length is not None and len(result) &gt; max_length:\n        result = result[:max_length]\n\n    return result\n</code></pre>"},{"location":"api/security/#taipanstack.security.sanitizers.sanitize_filename","title":"sanitize_filename","text":"<pre><code>sanitize_filename(\n    filename: str,\n    *,\n    max_length: int = 255,\n    replacement: str = \"_\",\n    preserve_extension: bool = True,\n) -&gt; str\n</code></pre> <p>Sanitize a filename to be safe for filesystem use.</p> <p>Removes or replaces characters that are: - Not allowed in filenames on various OSes - Potentially dangerous (path separators, etc.)</p> PARAMETER DESCRIPTION <code>filename</code> <p>The filename to sanitize.</p> <p> TYPE: <code>str</code> </p> <code>max_length</code> <p>Maximum length for the filename.</p> <p> TYPE: <code>int</code> DEFAULT: <code>255</code> </p> <code>replacement</code> <p>Character to replace invalid chars with.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'_'</code> </p> <code>preserve_extension</code> <p>Keep original extension.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The sanitized filename.</p> Example <p>sanitize_filename(\"my/../file&lt;&gt;:name.txt\") 'my_file_name.txt'</p> Source code in <code>src/taipanstack/security/sanitizers.py</code> <pre><code>def sanitize_filename(\n    filename: str,\n    *,\n    max_length: int = 255,\n    replacement: str = \"_\",\n    preserve_extension: bool = True,\n) -&gt; str:\n    \"\"\"Sanitize a filename to be safe for filesystem use.\n\n    Removes or replaces characters that are:\n    - Not allowed in filenames on various OSes\n    - Potentially dangerous (path separators, etc.)\n\n    Args:\n        filename: The filename to sanitize.\n        max_length: Maximum length for the filename.\n        replacement: Character to replace invalid chars with.\n        preserve_extension: Keep original extension.\n\n    Returns:\n        The sanitized filename.\n\n    Example:\n        &gt;&gt;&gt; sanitize_filename(\"my/../file&lt;&gt;:name.txt\")\n        'my_file_name.txt'\n\n    \"\"\"\n    if not isinstance(filename, str):\n        raise TypeError(f\"filename must be str, got {type(filename).__name__}\")\n\n    if not filename:\n        return \"unnamed\"\n\n    # Get parts\n    original_path = Path(filename)\n    stem = original_path.stem\n    suffix = original_path.suffix if preserve_extension else \"\"\n\n    # Remove invalid characters using precompiled regex for performance\n    safe_stem = _INVALID_FILENAME_CHARS_RE.sub(replacement, stem)\n\n    # Remove leading/trailing dots and spaces (Windows issues)\n    safe_stem = safe_stem.strip(\". \")\n\n    # Remove path separators that might have snuck through\n    safe_stem = safe_stem.replace(\"/\", replacement)\n    safe_stem = safe_stem.replace(\"\\\\\", replacement)\n\n    # Collapse multiple replacement chars\n    if replacement:\n        safe_stem = re.sub(f\"{re.escape(replacement)}+\", replacement, safe_stem)\n        safe_stem = safe_stem.strip(replacement)\n\n    # Handle reserved names (Windows)\n    if safe_stem.upper() in _WINDOWS_RESERVED_NAMES:\n        safe_stem = f\"{replacement}{safe_stem}\"\n\n    # Handle empty result\n    if not safe_stem:\n        safe_stem = \"unnamed\"\n\n    # Construct result\n    result = f\"{safe_stem}{suffix}\"\n\n    # Truncate if needed (keeping extension)\n    if len(result) &gt; max_length:\n        available = max_length - len(suffix)\n        if available &gt; 0:\n            safe_stem = safe_stem[:available]\n            result = f\"{safe_stem}{suffix}\"\n        else:\n            result = result[:max_length]\n\n    return result\n</code></pre>"},{"location":"api/security/#taipanstack.security.sanitizers.sanitize_path","title":"sanitize_path","text":"<pre><code>sanitize_path(\n    path: str | Path,\n    *,\n    base_dir: Path | None = None,\n    max_depth: int | None = 10,\n    resolve: bool = False,\n) -&gt; Path\n</code></pre> <p>Sanitize a path to prevent traversal and normalize it.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to sanitize.</p> <p> TYPE: <code>str | Path</code> </p> <code>base_dir</code> <p>Optional base directory to constrain to.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>max_depth</code> <p>Maximum directory depth allowed.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>10</code> </p> <code>resolve</code> <p>Whether to resolve the path (requires it to exist).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>The sanitized Path object.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If path is invalid or too deep.</p> Source code in <code>src/taipanstack/security/sanitizers.py</code> <pre><code>def sanitize_path(\n    path: str | Path,\n    *,\n    base_dir: Path | None = None,\n    max_depth: int | None = 10,\n    resolve: bool = False,\n) -&gt; Path:\n    \"\"\"Sanitize a path to prevent traversal and normalize it.\n\n    Args:\n        path: The path to sanitize.\n        base_dir: Optional base directory to constrain to.\n        max_depth: Maximum directory depth allowed.\n        resolve: Whether to resolve the path (requires it to exist).\n\n    Returns:\n        The sanitized Path object.\n\n    Raises:\n        ValueError: If path is invalid or too deep.\n\n    \"\"\"\n    if isinstance(path, str):  # pragma: no branch\n        path = Path(path)\n\n    # Remove any null bytes\n    path_str = str(path).replace(\"\\x00\", \"\")\n\n    # Normalize the path\n    path = Path(path_str)\n\n    # Remove any .. or . components manually\n    parts: list[str] = []\n    for part in path.parts:\n        if part == \"..\":\n            if parts and parts[-1] != \"..\":\n                parts.pop()\n            # Skip the .. entirely if at root\n        elif part != \".\":  # pragma: no branch\n            # Sanitize each component\n            safe_part = sanitize_filename(part, preserve_extension=True)\n            if safe_part:  # Skip empty parts  # pragma: no branch\n                parts.append(safe_part)\n\n    # Reconstruct path\n    if path.is_absolute():  # pragma: no branch\n        sanitized = (\n            Path(\"/\").joinpath(*parts) if parts else Path(\"/\")\n        )  # pragma: no cover\n    elif parts:  # pragma: no branch\n        sanitized = Path().joinpath(*parts)\n    else:  # pragma: no cover\n        sanitized = Path()\n\n    # Check depth (skip if max_depth is None)\n    depth = len(sanitized.parts)\n    if max_depth is not None and depth &gt; max_depth:\n        msg = f\"Path depth {depth} exceeds maximum of {max_depth}\"\n        raise ValueError(msg)\n\n    # Constrain to base_dir if provided\n    if base_dir is not None:\n        base = Path(base_dir).resolve()\n        if resolve:\n            try:\n                sanitized = sanitized.resolve()\n            except (OSError, RuntimeError) as e:\n                msg = f\"Cannot resolve path: {e}\"\n                raise ValueError(msg) from e\n        # Make absolute relative to base\n        elif not sanitized.is_absolute():  # pragma: no branch\n            sanitized = base / sanitized\n\n    return sanitized\n</code></pre>"},{"location":"api/security/#taipanstack.security.sanitizers.sanitize_env_value","title":"sanitize_env_value","text":"<pre><code>sanitize_env_value(\n    value: str,\n    *,\n    max_length: int = 4096,\n    allow_multiline: bool = False,\n) -&gt; str\n</code></pre> <p>Sanitize a value for use as an environment variable.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to sanitize.</p> <p> TYPE: <code>str</code> </p> <code>max_length</code> <p>Maximum length allowed.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4096</code> </p> <code>allow_multiline</code> <p>Whether to allow newlines.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The sanitized value.</p> Source code in <code>src/taipanstack/security/sanitizers.py</code> <pre><code>def sanitize_env_value(\n    value: str,\n    *,\n    max_length: int = 4096,\n    allow_multiline: bool = False,\n) -&gt; str:\n    \"\"\"Sanitize a value for use as an environment variable.\n\n    Args:\n        value: The value to sanitize.\n        max_length: Maximum length allowed.\n        allow_multiline: Whether to allow newlines.\n\n    Returns:\n        The sanitized value.\n\n    \"\"\"\n    if not value:\n        return \"\"\n\n    result = value\n\n    # Remove null bytes\n    result = result.replace(\"\\x00\", \"\")\n\n    # Handle newlines\n    if not allow_multiline:\n        result = result.replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n\n    # Truncate\n    if len(result) &gt; max_length:\n        result = result[:max_length]\n\n    return result\n</code></pre>"},{"location":"api/security/#taipanstack.security.sanitizers.sanitize_sql_identifier","title":"sanitize_sql_identifier","text":"<pre><code>sanitize_sql_identifier(identifier: str) -&gt; str\n</code></pre> <p>Sanitize a SQL identifier (table/column name).</p> <p>Note: This is NOT for SQL values - use parameterized queries for those!</p> PARAMETER DESCRIPTION <code>identifier</code> <p>The identifier to sanitize.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The sanitized identifier.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If identifier is empty or too long.</p> Source code in <code>src/taipanstack/security/sanitizers.py</code> <pre><code>def sanitize_sql_identifier(identifier: str) -&gt; str:\n    \"\"\"Sanitize a SQL identifier (table/column name).\n\n    Note: This is NOT for SQL values - use parameterized queries for those!\n\n    Args:\n        identifier: The identifier to sanitize.\n\n    Returns:\n        The sanitized identifier.\n\n    Raises:\n        ValueError: If identifier is empty or too long.\n\n    \"\"\"\n    if not identifier:\n        msg = \"SQL identifier cannot be empty\"\n        raise ValueError(msg)\n\n    # Only allow alphanumeric and underscore\n    result = re.sub(r\"[^a-zA-Z0-9_]\", \"\", identifier)\n\n    # Must start with letter or underscore\n    if result and not (result[0].isalpha() or result[0] == \"_\"):\n        result = f\"_{result}\"\n\n    # Check length (most DBs limit to 128 chars)\n    if len(result) &gt; MAX_SQL_IDENTIFIER_LENGTH:\n        result = result[:MAX_SQL_IDENTIFIER_LENGTH]\n\n    if not result:\n        msg = \"SQL identifier contains no valid characters\"\n        raise ValueError(msg)\n\n    return result\n</code></pre>"},{"location":"api/security/#validators","title":"Validators","text":"<p>Input validators for type-safe validation.</p> <p>Provides validation functions for common input types like email, project names, URLs, etc. All validators raise ValueError on invalid input.</p>"},{"location":"api/security/#taipanstack.security.validators.validate_project_name","title":"validate_project_name","text":"<pre><code>validate_project_name(\n    name: str,\n    *,\n    max_length: int = 100,\n    allow_hyphen: bool = True,\n    allow_underscore: bool = True,\n) -&gt; str\n</code></pre> <p>Validate a project name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The project name to validate.</p> <p> TYPE: <code>str</code> </p> <code>max_length</code> <p>Maximum allowed length.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>allow_hyphen</code> <p>Allow hyphens in name.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>allow_underscore</code> <p>Allow underscores in name.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated project name.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the name is invalid.</p> Example <p>validate_project_name(\"my_project\") 'my_project' validate_project_name(\"123project\") ValueError: Project name must start with a letter</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_project_name(\n    name: str,\n    *,\n    max_length: int = 100,\n    allow_hyphen: bool = True,\n    allow_underscore: bool = True,\n) -&gt; str:\n    \"\"\"Validate a project name.\n\n    Args:\n        name: The project name to validate.\n        max_length: Maximum allowed length.\n        allow_hyphen: Allow hyphens in name.\n        allow_underscore: Allow underscores in name.\n\n    Returns:\n        The validated project name.\n\n    Raises:\n        ValueError: If the name is invalid.\n\n    Example:\n        &gt;&gt;&gt; validate_project_name(\"my_project\")\n        'my_project'\n        &gt;&gt;&gt; validate_project_name(\"123project\")\n        ValueError: Project name must start with a letter\n\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError(f\"Project name must be str, got {type(name).__name__}\")\n\n    if not name:\n        msg = \"Project name cannot be empty\"\n        raise ValueError(msg)\n\n    if len(name) &gt; max_length:\n        msg = f\"Project name exceeds maximum length of {max_length}\"\n        raise ValueError(msg)\n\n    # Build allowed characters\n    allowed = r\"a-zA-Z0-9\"\n    if allow_hyphen:\n        allowed += r\"-\"\n    if allow_underscore:\n        allowed += r\"_\"\n\n    pattern = f\"^[a-zA-Z][{allowed}]*$\"\n\n    if not re.match(pattern, name):\n        if not name[0].isalpha():\n            msg = \"Project name must start with a letter\"\n            raise ValueError(msg)\n        hyphen_msg = \", hyphens\" if allow_hyphen else \"\"\n        underscore_msg = \", underscores\" if allow_underscore else \"\"\n        msg = (\n            f\"Project name contains invalid characters. \"\n            f\"Allowed: letters, numbers{hyphen_msg}{underscore_msg}\"\n        )\n        raise ValueError(msg)\n\n    # Check for reserved names\n    reserved = {\n        \"test\",\n        \"tests\",\n        \"src\",\n        \"lib\",\n        \"bin\",\n        \"build\",\n        \"dist\",\n        \"setup\",\n        \"config\",\n        \"settings\",\n        \"core\",\n        \"main\",\n        \"app\",\n        \"site-packages\",\n    }\n\n    if name.lower() in reserved:\n        msg = f\"Project name '{name}' is reserved\"\n        raise ValueError(msg)\n\n    return name\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_python_version","title":"validate_python_version","text":"<pre><code>validate_python_version(version: str) -&gt; str\n</code></pre> <p>Validate Python version string.</p> PARAMETER DESCRIPTION <code>version</code> <p>Version string like \"3.12\" or \"3.10\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated version string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If version format is invalid or unsupported.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_python_version(version: str) -&gt; str:\n    \"\"\"Validate Python version string.\n\n    Args:\n        version: Version string like \"3.12\" or \"3.10\".\n\n    Returns:\n        The validated version string.\n\n    Raises:\n        ValueError: If version format is invalid or unsupported.\n\n    \"\"\"\n    if not isinstance(version, str):\n        raise TypeError(f\"Version must be str, got {type(version).__name__}\")\n\n    pattern = r\"^\\d+\\.\\d+$\"\n\n    if not re.match(pattern, version):\n        msg = f\"Invalid version format: '{version}'. Use 'X.Y' format (e.g., '3.12')\"\n        raise ValueError(msg)\n\n    try:\n        major, minor = map(int, version.split(\".\"))\n    except ValueError as e:  # pragma: no cover \u2014 regex already validates digits\n        msg = f\"Invalid version numbers in '{version}'\"\n        raise ValueError(msg) from e\n\n    if major != PYTHON_MAJOR_VERSION:\n        msg = f\"Only Python 3.x is supported, got {major}.x\"\n        raise ValueError(msg)\n\n    if minor &lt; MIN_PYTHON_MINOR_VERSION:\n        msg = (\n            f\"Python 3.{minor} is not supported. \"\n            f\"Minimum is 3.{MIN_PYTHON_MINOR_VERSION}\"\n        )\n        raise ValueError(msg)\n\n    return version\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_email","title":"validate_email","text":"<pre><code>validate_email(email: str) -&gt; str\n</code></pre> <p>Validate email address format.</p> <p>Uses a reasonable regex pattern that covers most valid emails without being overly strict.</p> PARAMETER DESCRIPTION <code>email</code> <p>The email address to validate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated email address.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If email format is invalid.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_email(email: str) -&gt; str:\n    \"\"\"Validate email address format.\n\n    Uses a reasonable regex pattern that covers most valid emails\n    without being overly strict.\n\n    Args:\n        email: The email address to validate.\n\n    Returns:\n        The validated email address.\n\n    Raises:\n        ValueError: If email format is invalid.\n\n    \"\"\"\n    if not isinstance(email, str):\n        raise TypeError(f\"Email must be str, got {type(email).__name__}\")\n\n    if not email:\n        msg = \"Email cannot be empty\"\n        raise ValueError(msg)\n\n    # RFC 5322 compliant pattern (simplified)\n    pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n\n    if not re.match(pattern, email):\n        msg = f\"Invalid email format: {email}\"\n        raise ValueError(msg)\n\n    # Additional checks\n    local, domain = email.rsplit(\"@\", 1)\n\n    if len(local) &gt; MAX_EMAIL_LOCAL_LENGTH:\n        msg = f\"Email local part exceeds {MAX_EMAIL_LOCAL_LENGTH} characters\"\n        raise ValueError(msg)\n\n    if len(domain) &gt; MAX_EMAIL_DOMAIN_LENGTH:\n        msg = f\"Email domain exceeds {MAX_EMAIL_DOMAIN_LENGTH} characters\"\n        raise ValueError(msg)\n\n    return email\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_url","title":"validate_url","text":"<pre><code>validate_url(\n    url: str,\n    *,\n    allowed_schemes: tuple[str, ...] = (\"http\", \"https\"),\n    require_tld: bool = True,\n) -&gt; str\n</code></pre> <p>Validate URL format and scheme.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL to validate.</p> <p> TYPE: <code>str</code> </p> <code>allowed_schemes</code> <p>Tuple of allowed URL schemes.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('http', 'https')</code> </p> <code>require_tld</code> <p>Whether to require a TLD in the domain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The validated URL.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If URL format is invalid.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_url(\n    url: str,\n    *,\n    allowed_schemes: tuple[str, ...] = (\"http\", \"https\"),\n    require_tld: bool = True,\n) -&gt; str:\n    \"\"\"Validate URL format and scheme.\n\n    Args:\n        url: The URL to validate.\n        allowed_schemes: Tuple of allowed URL schemes.\n        require_tld: Whether to require a TLD in the domain.\n\n    Returns:\n        The validated URL.\n\n    Raises:\n        ValueError: If URL format is invalid.\n\n    \"\"\"\n    if not isinstance(url, str):\n        raise TypeError(f\"URL must be str, got {type(url).__name__}\")\n\n    if not url:\n        msg = \"URL cannot be empty\"\n        raise ValueError(msg)\n\n    try:\n        parsed = urlparse(url)\n    except ValueError as e:\n        msg = f\"Invalid URL format: {e}\"\n        raise ValueError(msg) from e\n\n    if not parsed.scheme:\n        msg = \"URL must have a scheme (e.g., https://)\"\n        raise ValueError(msg)\n\n    if parsed.scheme not in allowed_schemes:\n        msg = f\"URL scheme '{parsed.scheme}' is not allowed. Allowed: {allowed_schemes}\"\n        raise ValueError(msg)\n\n    if not parsed.netloc:\n        msg = \"URL must have a domain\"\n        raise ValueError(msg)\n\n    if require_tld:\n        # Check for TLD (at least one dot)\n        domain = parsed.netloc.split(\":\")[0]  # Remove port if present\n        has_no_tld = \".\" not in domain or domain.endswith(\".\")\n        is_localhost = domain.lower() in LOCALHOST_DOMAINS\n        if has_no_tld and not is_localhost:\n            msg = f\"URL domain must have a TLD: {domain}\"\n            raise ValueError(msg)\n\n    return url\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_ip_address","title":"validate_ip_address","text":"<pre><code>validate_ip_address(\n    ip: str,\n    *,\n    version: Literal[\"v4\", \"v6\", \"any\"] = \"any\",\n    allow_private: bool = True,\n) -&gt; IPv4Address | IPv6Address\n</code></pre> <p>Validate IP address.</p> PARAMETER DESCRIPTION <code>ip</code> <p>The IP address string to validate.</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>IP version to allow ('v4', 'v6', or 'any').</p> <p> TYPE: <code>Literal['v4', 'v6', 'any']</code> DEFAULT: <code>'any'</code> </p> <code>allow_private</code> <p>Whether to allow private/internal IPs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>IPv4Address | IPv6Address</code> <p>The validated IP address object.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If IP address is invalid.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_ip_address(\n    ip: str,\n    *,\n    version: Literal[\"v4\", \"v6\", \"any\"] = \"any\",\n    allow_private: bool = True,\n) -&gt; IPv4Address | IPv6Address:\n    \"\"\"Validate IP address.\n\n    Args:\n        ip: The IP address string to validate.\n        version: IP version to allow ('v4', 'v6', or 'any').\n        allow_private: Whether to allow private/internal IPs.\n\n    Returns:\n        The validated IP address object.\n\n    Raises:\n        ValueError: If IP address is invalid.\n\n    \"\"\"\n    try:\n        addr = ip_address(ip)\n    except ValueError as e:\n        msg = f\"Invalid IP address: {ip}\"\n        raise ValueError(msg) from e\n\n    if version == \"v4\" and not isinstance(addr, IPv4Address):\n        msg = f\"Expected IPv4 address, got IPv6: {ip}\"\n        raise ValueError(msg)\n\n    if version == \"v6\" and not isinstance(addr, IPv6Address):\n        msg = f\"Expected IPv6 address, got IPv4: {ip}\"\n        raise ValueError(msg)\n\n    if not allow_private and addr.is_private:\n        msg = f\"Private IP addresses are not allowed: {ip}\"\n        raise ValueError(msg)\n\n    return addr\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_port","title":"validate_port","text":"<pre><code>validate_port(\n    port: int | str, *, allow_privileged: bool = False\n) -&gt; int\n</code></pre> <p>Validate port number.</p> PARAMETER DESCRIPTION <code>port</code> <p>The port number to validate.</p> <p> TYPE: <code>int | str</code> </p> <code>allow_privileged</code> <p>Whether to allow ports below 1024.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The validated port number.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If port is invalid.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_port(\n    port: int | str,\n    *,\n    allow_privileged: bool = False,\n) -&gt; int:\n    \"\"\"Validate port number.\n\n    Args:\n        port: The port number to validate.\n        allow_privileged: Whether to allow ports below 1024.\n\n    Returns:\n        The validated port number.\n\n    Raises:\n        ValueError: If port is invalid.\n\n    \"\"\"\n    try:\n        port_int = int(port)\n    except ValueError as e:\n        msg = f\"Invalid port number: {port}\"\n        raise ValueError(msg) from e\n\n    if port_int &lt; 0 or port_int &gt; MAX_PORT_NUMBER:\n        msg = f\"Port must be between 0 and {MAX_PORT_NUMBER}: {port_int}\"\n        raise ValueError(msg)\n\n    if not allow_privileged and port_int &lt; MIN_PRIVILEGED_PORT:\n        msg = f\"Privileged ports (&lt; {MIN_PRIVILEGED_PORT}) are not allowed: {port_int}\"\n        raise ValueError(msg)\n\n    return port_int\n</code></pre>"},{"location":"api/security/#taipanstack.security.validators.validate_semver","title":"validate_semver","text":"<pre><code>validate_semver(version: str) -&gt; tuple[int, int, int]\n</code></pre> <p>Validate semantic version string.</p> PARAMETER DESCRIPTION <code>version</code> <p>Version string like \"1.2.3\" or \"v1.2.3\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[int, int, int]</code> <p>Tuple of (major, minor, patch).</p> RAISES DESCRIPTION <code>ValueError</code> <p>If version format is invalid.</p> Source code in <code>src/taipanstack/security/validators.py</code> <pre><code>def validate_semver(version: str) -&gt; tuple[int, int, int]:\n    \"\"\"Validate semantic version string.\n\n    Args:\n        version: Version string like \"1.2.3\" or \"v1.2.3\".\n\n    Returns:\n        Tuple of (major, minor, patch).\n\n    Raises:\n        ValueError: If version format is invalid.\n\n    \"\"\"\n    # Remove leading 'v' if present\n    version = version.lstrip(\"vV\")\n\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)(?:-[a-zA-Z0-9.]+)?(?:\\+[a-zA-Z0-9.]+)?$\"\n    match = re.match(pattern, version)\n\n    if not match:\n        msg = f\"Invalid semantic version: {version}. Expected format: X.Y.Z\"\n        raise ValueError(msg)\n\n    major, minor, patch = map(int, match.groups()[:3])\n\n    return major, minor, patch\n</code></pre>"},{"location":"api/utils/","title":"Utilities \u2014 Retry, Circuit Breaker &amp; Metrics","text":"<p>TaipanStack provides resilience and observability utilities for production applications.</p>"},{"location":"api/utils/#retry","title":"Retry","text":"<p>Retry logic with exponential backoff.</p> <p>Provides decorators for automatic retry of failing operations with configurable backoff strategies. Compatible with any Python framework (sync and async).</p>"},{"location":"api/utils/#taipanstack.utils.retry.RetryConfig","title":"RetryConfig  <code>dataclass</code>","text":"<pre><code>RetryConfig(\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 60.0,\n    exponential_base: float = 2.0,\n    jitter: bool = True,\n    jitter_factor: float = 0.1,\n)\n</code></pre> <p>Configuration for retry behavior.</p> ATTRIBUTE DESCRIPTION <code>max_attempts</code> <p>Maximum number of retry attempts.</p> <p> TYPE: <code>int</code> </p> <code>initial_delay</code> <p>Initial delay between retries in seconds.</p> <p> TYPE: <code>float</code> </p> <code>max_delay</code> <p>Maximum delay between retries.</p> <p> TYPE: <code>float</code> </p> <code>exponential_base</code> <p>Base for exponential backoff (2 = double each time).</p> <p> TYPE: <code>float</code> </p> <code>jitter</code> <p>Whether to add random jitter to delays.</p> <p> TYPE: <code>bool</code> </p> <code>jitter_factor</code> <p>Maximum jitter as fraction of delay (0.1 = 10%).</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/utils/#taipanstack.utils.retry.RetryError","title":"RetryError","text":"<pre><code>RetryError(\n    message: str,\n    attempts: int,\n    last_exception: Exception | None = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when all retry attempts have failed.</p> <p>Initialize RetryError.</p> PARAMETER DESCRIPTION <code>message</code> <p>Description of the retry failure.</p> <p> TYPE: <code>str</code> </p> <code>attempts</code> <p>Number of attempts made.</p> <p> TYPE: <code>int</code> </p> <code>last_exception</code> <p>The last exception that was raised.</p> <p> TYPE: <code>Exception | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    attempts: int,\n    last_exception: Exception | None = None,\n) -&gt; None:\n    \"\"\"Initialize RetryError.\n\n    Args:\n        message: Description of the retry failure.\n        attempts: Number of attempts made.\n        last_exception: The last exception that was raised.\n\n    \"\"\"\n    self.attempts = attempts\n    self.last_exception = last_exception\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.Retrier","title":"Retrier","text":"<pre><code>Retrier(\n    *,\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 60.0,\n    on: tuple[type[Exception], ...] = (Exception,),\n)\n</code></pre> <p>Context manager for retry logic.</p> <p>Provides a context manager interface for retry logic when decorators are not suitable.</p> Example <p>retrier = Retrier(max_attempts=3, on=(ConnectionError,)) with retrier: ...     result = some_operation()</p> <p>Initialize Retrier.</p> PARAMETER DESCRIPTION <code>max_attempts</code> <p>Maximum retry attempts.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>initial_delay</code> <p>Initial delay between retries.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>max_delay</code> <p>Maximum delay between retries.</p> <p> TYPE: <code>float</code> DEFAULT: <code>60.0</code> </p> <code>on</code> <p>Exception types to retry on.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>(Exception,)</code> </p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def __init__(\n    self,\n    *,\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 60.0,\n    on: tuple[type[Exception], ...] = (Exception,),\n) -&gt; None:\n    \"\"\"Initialize Retrier.\n\n    Args:\n        max_attempts: Maximum retry attempts.\n        initial_delay: Initial delay between retries.\n        max_delay: Maximum delay between retries.\n        on: Exception types to retry on.\n\n    \"\"\"\n    self.config = RetryConfig(\n        max_attempts=max_attempts,\n        initial_delay=initial_delay,\n        max_delay=max_delay,\n    )\n    self.exception_types = on\n    self.attempt = 0\n    self.last_exception: Exception | None = None\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.Retrier.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Retrier\n</code></pre> <p>Enter the retry context.</p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def __enter__(self) -&gt; Retrier:\n    \"\"\"Enter the retry context.\"\"\"\n    self.attempt = 0\n    self.last_exception = None\n    return self\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.Retrier.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool\n</code></pre> <p>Exit the retry context.</p> <p>Returns True to suppress the exception if we should retry, False to let it propagate.</p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool:\n    \"\"\"Exit the retry context.\n\n    Returns True to suppress the exception if we should retry,\n    False to let it propagate.\n    \"\"\"\n    if exc_type is None:\n        return False  # No exception, exit normally\n\n    if not issubclass(exc_type, self.exception_types):\n        return False  # Exception type not in retry list\n\n    # Safe cast: issubclass guard above ensures exc_val is Exception\n    self.last_exception = exc_val if isinstance(exc_val, Exception) else None\n    self.attempt += 1\n\n    if self.attempt &gt;= self.config.max_attempts:\n        return False  # Max attempts reached, propagate exception\n\n    # Calculate delay and wait\n    delay = calculate_delay(self.attempt, self.config)\n    time.sleep(delay)\n\n    return True  # Suppress exception and retry\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.calculate_delay","title":"calculate_delay","text":"<pre><code>calculate_delay(attempt: int, config: RetryConfig) -&gt; float\n</code></pre> <p>Calculate delay before next retry.</p> PARAMETER DESCRIPTION <code>attempt</code> <p>Current attempt number (1-indexed).</p> <p> TYPE: <code>int</code> </p> <code>config</code> <p>Retry configuration.</p> <p> TYPE: <code>RetryConfig</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Delay in seconds before next retry.</p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def calculate_delay(\n    attempt: int,\n    config: RetryConfig,\n) -&gt; float:\n    \"\"\"Calculate delay before next retry.\n\n    Args:\n        attempt: Current attempt number (1-indexed).\n        config: Retry configuration.\n\n    Returns:\n        Delay in seconds before next retry.\n\n    \"\"\"\n    # Exponential backoff\n    delay = config.initial_delay * (config.exponential_base ** (attempt - 1))\n\n    # Cap at max delay\n    delay = min(delay, config.max_delay)\n\n    # Add jitter if enabled\n    # Note: Using random for jitter is intentionally non-cryptographic.\n    # Jitter is for load distribution, not security. Using secrets would be overkill.\n    if config.jitter:\n        jitter_amount = delay * config.jitter_factor\n        delay += random.uniform(-jitter_amount, jitter_amount)\n\n    return max(0, delay)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.retry","title":"retry","text":"<pre><code>retry(\n    *,\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 60.0,\n    exponential_base: float = 2.0,\n    jitter: bool = True,\n    on: tuple[type[Exception], ...] = (Exception,),\n    reraise: bool = True,\n    log_retries: bool = True,\n    on_retry: Callable[[int, int, Exception, float], None]\n    | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Retry a function with exponential backoff.</p> <p>Automatically retries the decorated function when specified exceptions are raised, with configurable backoff strategy.</p> PARAMETER DESCRIPTION <code>max_attempts</code> <p>Maximum number of retry attempts.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>initial_delay</code> <p>Initial delay between retries in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>max_delay</code> <p>Maximum delay between retries.</p> <p> TYPE: <code>float</code> DEFAULT: <code>60.0</code> </p> <code>exponential_base</code> <p>Base for exponential backoff.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>jitter</code> <p>Whether to add random jitter to delays.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>on</code> <p>Exception types to retry on.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>(Exception,)</code> </p> <code>reraise</code> <p>Whether to reraise the last exception on failure.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>log_retries</code> <p>Whether to log retry attempts.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>on_retry</code> <p>Optional callback invoked on each retry with (attempt, max_attempts, exception, delay). Useful for custom monitoring or metrics collection.</p> <p> TYPE: <code>Callable[[int, int, Exception, float], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with retry logic.</p> Example <p>@retry(max_attempts=3, on=(ConnectionError, TimeoutError)) ... def fetch_data(url: str) -&gt; dict: ...     return requests.get(url).json()</p> <p>@retry(max_attempts=3, on_retry=lambda a, m, e, d: print(f\"Retry {a}/{m}\")) ... def fragile_operation() -&gt; str: ...     return do_something()</p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def retry(\n    *,\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 60.0,\n    exponential_base: float = 2.0,\n    jitter: bool = True,\n    on: tuple[type[Exception], ...] = (Exception,),\n    reraise: bool = True,\n    log_retries: bool = True,\n    on_retry: Callable[[int, int, Exception, float], None] | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Retry a function with exponential backoff.\n\n    Automatically retries the decorated function when specified\n    exceptions are raised, with configurable backoff strategy.\n\n    Args:\n        max_attempts: Maximum number of retry attempts.\n        initial_delay: Initial delay between retries in seconds.\n        max_delay: Maximum delay between retries.\n        exponential_base: Base for exponential backoff.\n        jitter: Whether to add random jitter to delays.\n        on: Exception types to retry on.\n        reraise: Whether to reraise the last exception on failure.\n        log_retries: Whether to log retry attempts.\n        on_retry: Optional callback invoked on each retry with\n            (attempt, max_attempts, exception, delay). Useful for\n            custom monitoring or metrics collection.\n\n    Returns:\n        Decorated function with retry logic.\n\n    Example:\n        &gt;&gt;&gt; @retry(max_attempts=3, on=(ConnectionError, TimeoutError))\n        ... def fetch_data(url: str) -&gt; dict:\n        ...     return requests.get(url).json()\n\n        &gt;&gt;&gt; @retry(max_attempts=3, on_retry=lambda a, m, e, d: print(f\"Retry {a}/{m}\"))\n        ... def fragile_operation() -&gt; str:\n        ...     return do_something()\n\n    \"\"\"\n    config = RetryConfig(\n        max_attempts=max_attempts,\n        initial_delay=initial_delay,\n        max_delay=max_delay,\n        exponential_base=exponential_base,\n        jitter=jitter,\n    )\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            last_exception: Exception | None = None\n\n            for attempt in range(1, max_attempts + 1):  # pragma: no branch\n                try:\n                    return func(*args, **kwargs)\n                except on as e:\n                    last_exception = e\n\n                    if attempt == max_attempts:\n                        # Last attempt failed\n                        if log_retries:\n                            logger.warning(\n                                \"All %d attempts failed for %s: %s\",\n                                max_attempts,\n                                func.__name__,\n                                str(e),\n                            )\n                        break\n\n                    # Calculate delay and wait\n                    delay = calculate_delay(attempt, config)\n\n                    if log_retries:\n                        logger.info(\n                            \"Attempt %d/%d failed for %s: %s. \"\n                            \"Retrying in %.2f seconds...\",\n                            attempt,\n                            max_attempts,\n                            func.__name__,\n                            str(e),\n                            delay,\n                        )\n\n                    # Invoke callback if provided\n                    if on_retry is not None:\n                        on_retry(attempt, max_attempts, e, delay)\n\n                    time.sleep(delay)\n\n            # All attempts failed\n            if reraise and last_exception is not None:\n                raise RetryError(\n                    f\"All {max_attempts} attempts failed for {func.__name__}\",\n                    attempts=max_attempts,\n                    last_exception=last_exception,\n                ) from last_exception\n\n            # Should never reach here if reraise=True\n            raise RetryError(\n                f\"All {max_attempts} attempts failed for {func.__name__}\",\n                attempts=max_attempts,\n                last_exception=last_exception,\n            )\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.retry.retry_on_exception","title":"retry_on_exception","text":"<pre><code>retry_on_exception(\n    exception_types: tuple[type[Exception], ...],\n    max_attempts: int = 3,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Retry on specific exceptions.</p> <p>A simpler alternative to the full retry decorator when you just need basic retry functionality.</p> PARAMETER DESCRIPTION <code>exception_types</code> <p>Exception types to retry on.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> </p> <code>max_attempts</code> <p>Maximum number of attempts.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with retry logic.</p> Example <p>@retry_on_exception((ValueError,), max_attempts=2) ... def parse_data(data: str) -&gt; dict: ...     return json.loads(data)</p> Source code in <code>src/taipanstack/utils/retry.py</code> <pre><code>def retry_on_exception(\n    exception_types: tuple[type[Exception], ...],\n    max_attempts: int = 3,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Retry on specific exceptions.\n\n    A simpler alternative to the full retry decorator when you\n    just need basic retry functionality.\n\n    Args:\n        exception_types: Exception types to retry on.\n        max_attempts: Maximum number of attempts.\n\n    Returns:\n        Decorated function with retry logic.\n\n    Example:\n        &gt;&gt;&gt; @retry_on_exception((ValueError,), max_attempts=2)\n        ... def parse_data(data: str) -&gt; dict:\n        ...     return json.loads(data)\n\n    \"\"\"\n    return retry(\n        max_attempts=max_attempts,\n        on=exception_types,\n        jitter=False,\n        log_retries=False,\n    )\n</code></pre>"},{"location":"api/utils/#circuit-breaker","title":"Circuit Breaker","text":"<p>Circuit Breaker pattern implementation.</p> <p>Provides protection against cascading failures by temporarily blocking calls to a failing service. Compatible with any Python framework.</p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitState","title":"CircuitState","text":"<p>               Bases: <code>Enum</code></p> <p>States of the circuit breaker.</p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreakerError","title":"CircuitBreakerError","text":"<pre><code>CircuitBreakerError(message: str, state: CircuitState)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when circuit breaker is open.</p> <p>Initialize CircuitBreakerError.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error description.</p> <p> TYPE: <code>str</code> </p> <code>state</code> <p>Current circuit state.</p> <p> TYPE: <code>CircuitState</code> </p> Source code in <code>src/taipanstack/utils/circuit_breaker.py</code> <pre><code>def __init__(self, message: str, state: CircuitState) -&gt; None:\n    \"\"\"Initialize CircuitBreakerError.\n\n    Args:\n        message: Error description.\n        state: Current circuit state.\n\n    \"\"\"\n    self.state = state\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreakerConfig","title":"CircuitBreakerConfig  <code>dataclass</code>","text":"<pre><code>CircuitBreakerConfig(\n    failure_threshold: int = 5,\n    success_threshold: int = 2,\n    timeout: float = 30.0,\n    excluded_exceptions: tuple[type[Exception], ...] = (),\n)\n</code></pre> <p>Configuration for circuit breaker behavior.</p> ATTRIBUTE DESCRIPTION <code>failure_threshold</code> <p>Number of failures before opening circuit.</p> <p> TYPE: <code>int</code> </p> <code>success_threshold</code> <p>Successes needed in half-open to close.</p> <p> TYPE: <code>int</code> </p> <code>timeout</code> <p>Seconds before trying half-open after open.</p> <p> TYPE: <code>float</code> </p> <code>excluded_exceptions</code> <p>Exceptions that don't count as failures.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> </p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreakerState","title":"CircuitBreakerState  <code>dataclass</code>","text":"<pre><code>CircuitBreakerState(\n    state: CircuitState = CLOSED,\n    failure_count: int = 0,\n    success_count: int = 0,\n    last_failure_time: float = 0.0,\n    lock: Lock = Lock(),\n)\n</code></pre> <p>Internal state tracking for circuit breaker.</p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreaker","title":"CircuitBreaker","text":"<pre><code>CircuitBreaker(\n    *,\n    failure_threshold: int = 5,\n    success_threshold: int = 2,\n    timeout: float = 30.0,\n    excluded_exceptions: tuple[type[Exception], ...] = (),\n    name: str = \"default\",\n    on_state_change: Callable[\n        [CircuitState, CircuitState], None\n    ]\n    | None = None,\n)\n</code></pre> <p>Circuit breaker implementation.</p> <p>Monitors function calls and opens the circuit when too many failures occur, preventing further calls until the service recovers.</p> Example <p>breaker = CircuitBreaker(failure_threshold=3) @breaker ... def call_external_api(): ...     return requests.get(\"https://api.example.com\")</p> <p>Initialize CircuitBreaker.</p> PARAMETER DESCRIPTION <code>failure_threshold</code> <p>Failures before opening circuit.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>success_threshold</code> <p>Successes to close from half-open.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>timeout</code> <p>Seconds before attempting half-open.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>excluded_exceptions</code> <p>Exceptions that don't trip circuit.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>()</code> </p> <code>name</code> <p>Name for logging/identification.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'default'</code> </p> <code>on_state_change</code> <p>Optional callback invoked on state transitions with (old_state, new_state). Useful for custom monitoring.</p> <p> TYPE: <code>Callable[[CircuitState, CircuitState], None] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/taipanstack/utils/circuit_breaker.py</code> <pre><code>def __init__(\n    self,\n    *,\n    failure_threshold: int = 5,\n    success_threshold: int = 2,\n    timeout: float = 30.0,\n    excluded_exceptions: tuple[type[Exception], ...] = (),\n    name: str = \"default\",\n    on_state_change: Callable[[CircuitState, CircuitState], None] | None = None,\n) -&gt; None:\n    \"\"\"Initialize CircuitBreaker.\n\n    Args:\n        failure_threshold: Failures before opening circuit.\n        success_threshold: Successes to close from half-open.\n        timeout: Seconds before attempting half-open.\n        excluded_exceptions: Exceptions that don't trip circuit.\n        name: Name for logging/identification.\n        on_state_change: Optional callback invoked on state transitions\n            with (old_state, new_state). Useful for custom monitoring.\n\n    \"\"\"\n    self.config = CircuitBreakerConfig(\n        failure_threshold=failure_threshold,\n        success_threshold=success_threshold,\n        timeout=timeout,\n        excluded_exceptions=excluded_exceptions,\n    )\n    self.name = name\n    self._state = CircuitBreakerState()\n    self._on_state_change = on_state_change\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreaker.state","title":"state  <code>property</code>","text":"<pre><code>state: CircuitState\n</code></pre> <p>Get current circuit state.</p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreaker.failure_count","title":"failure_count  <code>property</code>","text":"<pre><code>failure_count: int\n</code></pre> <p>Get current failure count.</p>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreaker.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset circuit breaker to closed state.</p> Source code in <code>src/taipanstack/utils/circuit_breaker.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset circuit breaker to closed state.\"\"\"\n    with self._state.lock:\n        self._state.state = CircuitState.CLOSED\n        self._state.failure_count = 0\n        self._state.success_count = 0\n        logger.info(\"Circuit %s manually reset\", self.name)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.CircuitBreaker.__call__","title":"__call__","text":"<pre><code>__call__(func: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Decorate a function with circuit breaker protection.</p> Source code in <code>src/taipanstack/utils/circuit_breaker.py</code> <pre><code>def __call__(self, func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorate a function with circuit breaker protection.\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if not self._should_attempt():\n            raise CircuitBreakerError(\n                f\"Circuit {self.name} is open\",\n                state=self._state.state,\n            )\n\n        try:\n            result = func(*args, **kwargs)\n            self._record_success()\n            return result\n        except Exception as e:\n            self._record_failure(e)\n            raise\n\n    return wrapper\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.circuit_breaker.circuit_breaker","title":"circuit_breaker","text":"<pre><code>circuit_breaker(\n    *,\n    failure_threshold: int = 5,\n    success_threshold: int = 2,\n    timeout: float = 30.0,\n    excluded_exceptions: tuple[type[Exception], ...] = (),\n    name: str | None = None,\n    on_state_change: Callable[\n        [CircuitState, CircuitState], None\n    ]\n    | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator to apply circuit breaker pattern.</p> PARAMETER DESCRIPTION <code>failure_threshold</code> <p>Failures before opening circuit.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>success_threshold</code> <p>Successes to close from half-open.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>timeout</code> <p>Seconds before attempting half-open.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>excluded_exceptions</code> <p>Exceptions that don't trip circuit.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>()</code> </p> <code>name</code> <p>Optional name for the circuit.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>on_state_change</code> <p>Optional callback invoked on state transitions with (old_state, new_state).</p> <p> TYPE: <code>Callable[[CircuitState, CircuitState], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with circuit breaker protection.</p> Example <p>@circuit_breaker(failure_threshold=3, timeout=60) ... def call_api(endpoint: str) -&gt; dict: ...     return requests.get(endpoint).json()</p> <p>@circuit_breaker( ...     failure_threshold=3, ...     on_state_change=lambda old, new: print(f\"{old} -&gt; {new}\"), ... ) ... def monitored_call() -&gt; str: ...     return service.call()</p> Source code in <code>src/taipanstack/utils/circuit_breaker.py</code> <pre><code>def circuit_breaker(\n    *,\n    failure_threshold: int = 5,\n    success_threshold: int = 2,\n    timeout: float = 30.0,\n    excluded_exceptions: tuple[type[Exception], ...] = (),\n    name: str | None = None,\n    on_state_change: Callable[[CircuitState, CircuitState], None] | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Decorator to apply circuit breaker pattern.\n\n    Args:\n        failure_threshold: Failures before opening circuit.\n        success_threshold: Successes to close from half-open.\n        timeout: Seconds before attempting half-open.\n        excluded_exceptions: Exceptions that don't trip circuit.\n        name: Optional name for the circuit.\n        on_state_change: Optional callback invoked on state transitions\n            with (old_state, new_state).\n\n    Returns:\n        Decorated function with circuit breaker protection.\n\n    Example:\n        &gt;&gt;&gt; @circuit_breaker(failure_threshold=3, timeout=60)\n        ... def call_api(endpoint: str) -&gt; dict:\n        ...     return requests.get(endpoint).json()\n\n        &gt;&gt;&gt; @circuit_breaker(\n        ...     failure_threshold=3,\n        ...     on_state_change=lambda old, new: print(f\"{old} -&gt; {new}\"),\n        ... )\n        ... def monitored_call() -&gt; str:\n        ...     return service.call()\n\n    \"\"\"\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        breaker = CircuitBreaker(\n            failure_threshold=failure_threshold,\n            success_threshold=success_threshold,\n            timeout=timeout,\n            excluded_exceptions=excluded_exceptions,\n            name=name or func.__name__,\n            on_state_change=on_state_change,\n        )\n        return breaker(func)\n\n    return decorator\n</code></pre>"},{"location":"api/utils/#metrics","title":"Metrics","text":"<p>Metrics collection and monitoring utilities.</p> <p>Provides lightweight metrics collection for monitoring application performance and health. Compatible with any Python framework.</p>"},{"location":"api/utils/#taipanstack.utils.metrics.TimingStats","title":"TimingStats  <code>dataclass</code>","text":"<pre><code>TimingStats(\n    count: int = 0,\n    total_time: float = 0.0,\n    min_time: float = float(\"inf\"),\n    max_time: float = 0.0,\n)\n</code></pre> <p>Statistics for timing measurements.</p>"},{"location":"api/utils/#taipanstack.utils.metrics.TimingStats.avg_time","title":"avg_time  <code>property</code>","text":"<pre><code>avg_time: float\n</code></pre> <p>Calculate average time.</p>"},{"location":"api/utils/#taipanstack.utils.metrics.TimingStats.record","title":"record","text":"<pre><code>record(duration: float) -&gt; None\n</code></pre> <p>Record a timing measurement.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def record(self, duration: float) -&gt; None:\n    \"\"\"Record a timing measurement.\"\"\"\n    self.count += 1\n    self.total_time += duration\n    self.min_time = min(self.min_time, duration)\n    self.max_time = max(self.max_time, duration)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Counter","title":"Counter  <code>dataclass</code>","text":"<pre><code>Counter(value: int = 0, lock: Lock = Lock())\n</code></pre> <p>Simple counter metric.</p>"},{"location":"api/utils/#taipanstack.utils.metrics.Counter.increment","title":"increment","text":"<pre><code>increment(amount: int = 1) -&gt; int\n</code></pre> <p>Increment counter and return new value.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def increment(self, amount: int = 1) -&gt; int:\n    \"\"\"Increment counter and return new value.\"\"\"\n    with self.lock:\n        self.value += amount\n        return self.value\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Counter.decrement","title":"decrement","text":"<pre><code>decrement(amount: int = 1) -&gt; int\n</code></pre> <p>Decrement counter and return new value.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def decrement(self, amount: int = 1) -&gt; int:\n    \"\"\"Decrement counter and return new value.\"\"\"\n    with self.lock:\n        self.value -= amount\n        return self.value\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Counter.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset counter to zero.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset counter to zero.\"\"\"\n    with self.lock:\n        self.value = 0\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector","title":"MetricsCollector","text":"<pre><code>MetricsCollector()\n</code></pre> <p>Centralized metrics collection.</p> <p>Thread-safe collector for various metric types including counters, timers, and gauges.</p> Example <p>metrics = MetricsCollector() metrics.increment(\"requests_total\") with metrics.timer(\"request_duration\"): ...     process_request()</p> <p>Initialize metrics collector.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize metrics collector.\"\"\"\n    if self._initialized:\n        return\n\n    self._counters: dict[str, Counter] = defaultdict(Counter)\n    self._timers: dict[str, TimingStats] = defaultdict(TimingStats)\n    self._gauges: dict[str, float] = {}\n    self._data_lock = threading.Lock()\n    self._initialized = True\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; MetricsCollector\n</code></pre> <p>Singleton pattern for global metrics access.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def __new__(cls) -&gt; MetricsCollector:\n    \"\"\"Singleton pattern for global metrics access.\"\"\"\n    if cls._instance is None:\n        with cls._lock:\n            if cls._instance is None:  # pragma: no branch\n                cls._instance = super().__new__(cls)\n                cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.increment","title":"increment","text":"<pre><code>increment(name: str, amount: int = 1) -&gt; int\n</code></pre> <p>Increment a counter metric.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def increment(self, name: str, amount: int = 1) -&gt; int:\n    \"\"\"Increment a counter metric.\"\"\"\n    return self._counters[name].increment(amount)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.decrement","title":"decrement","text":"<pre><code>decrement(name: str, amount: int = 1) -&gt; int\n</code></pre> <p>Decrement a counter metric.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def decrement(self, name: str, amount: int = 1) -&gt; int:\n    \"\"\"Decrement a counter metric.\"\"\"\n    return self._counters[name].decrement(amount)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.gauge","title":"gauge","text":"<pre><code>gauge(name: str, value: float) -&gt; None\n</code></pre> <p>Set a gauge metric value.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def gauge(self, name: str, value: float) -&gt; None:\n    \"\"\"Set a gauge metric value.\"\"\"\n    with self._data_lock:\n        self._gauges[name] = value\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.get_gauge","title":"get_gauge","text":"<pre><code>get_gauge(name: str) -&gt; float | None\n</code></pre> <p>Get a gauge metric value.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def get_gauge(self, name: str) -&gt; float | None:\n    \"\"\"Get a gauge metric value.\"\"\"\n    with self._data_lock:\n        return self._gauges.get(name)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.record_time","title":"record_time","text":"<pre><code>record_time(name: str, duration: float) -&gt; None\n</code></pre> <p>Record a timing measurement.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def record_time(self, name: str, duration: float) -&gt; None:\n    \"\"\"Record a timing measurement.\"\"\"\n    self._timers[name].record(duration)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.timer","title":"timer","text":"<pre><code>timer(name: str) -&gt; Timer\n</code></pre> <p>Create a context manager timer.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def timer(self, name: str) -&gt; Timer:\n    \"\"\"Create a context manager timer.\"\"\"\n    return Timer(name, self)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.get_counter","title":"get_counter","text":"<pre><code>get_counter(name: str) -&gt; int\n</code></pre> <p>Get current counter value.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def get_counter(self, name: str) -&gt; int:\n    \"\"\"Get current counter value.\"\"\"\n    return self._counters[name].value\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.get_timer_stats","title":"get_timer_stats","text":"<pre><code>get_timer_stats(name: str) -&gt; TimingStats | None\n</code></pre> <p>Get timing statistics for a named timer.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def get_timer_stats(self, name: str) -&gt; TimingStats | None:\n    \"\"\"Get timing statistics for a named timer.\"\"\"\n    return self._timers.get(name)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.get_all_metrics","title":"get_all_metrics","text":"<pre><code>get_all_metrics() -&gt; dict[str, Any]\n</code></pre> <p>Get all metrics as a dictionary.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def get_all_metrics(self) -&gt; dict[str, Any]:\n    \"\"\"Get all metrics as a dictionary.\"\"\"\n    with self._data_lock:\n        return {\n            \"counters\": {k: v.value for k, v in self._counters.items()},\n            \"timers\": {\n                k: {\n                    \"count\": v.count,\n                    \"avg\": v.avg_time,\n                    \"min\": v.min_time if v.count &gt; 0 else 0,\n                    \"max\": v.max_time,\n                    \"total\": v.total_time,\n                }\n                for k, v in self._timers.items()\n            },\n            \"gauges\": dict(self._gauges),\n        }\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.MetricsCollector.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset all metrics.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset all metrics.\"\"\"\n    with self._data_lock:\n        self._counters.clear()\n        self._timers.clear()\n        self._gauges.clear()\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Timer","title":"Timer","text":"<pre><code>Timer(name: str, collector: MetricsCollector)\n</code></pre> <p>Context manager for timing code blocks.</p> <p>Initialize timer.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the timer metric.</p> <p> TYPE: <code>str</code> </p> <code>collector</code> <p>MetricsCollector to record to.</p> <p> TYPE: <code>MetricsCollector</code> </p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def __init__(self, name: str, collector: MetricsCollector) -&gt; None:\n    \"\"\"Initialize timer.\n\n    Args:\n        name: Name of the timer metric.\n        collector: MetricsCollector to record to.\n\n    \"\"\"\n    self.name = name\n    self.collector = collector\n    self.start_time: float = 0.0\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Timer.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Timer\n</code></pre> <p>Start the timer.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def __enter__(self) -&gt; Timer:\n    \"\"\"Start the timer.\"\"\"\n    self.start_time = time.perf_counter()\n    return self\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.Timer.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: Any) -&gt; None\n</code></pre> <p>Stop timer and record duration.</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def __exit__(self, *args: Any) -&gt; None:\n    \"\"\"Stop timer and record duration.\"\"\"\n    duration = time.perf_counter() - self.start_time\n    self.collector.record_time(self.name, duration)\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.timed","title":"timed","text":"<pre><code>timed(\n    name: str | None = None,\n    *,\n    collector: MetricsCollector | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator to time function execution.</p> PARAMETER DESCRIPTION <code>name</code> <p>Optional metric name (defaults to function name).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>collector</code> <p>Optional MetricsCollector instance.</p> <p> TYPE: <code>MetricsCollector | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function that records execution time.</p> Example <p>@timed(\"api_call_duration\") ... def call_api(endpoint: str) -&gt; dict: ...     return requests.get(endpoint).json()</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def timed(\n    name: str | None = None,\n    *,\n    collector: MetricsCollector | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Decorator to time function execution.\n\n    Args:\n        name: Optional metric name (defaults to function name).\n        collector: Optional MetricsCollector instance.\n\n    Returns:\n        Decorated function that records execution time.\n\n    Example:\n        &gt;&gt;&gt; @timed(\"api_call_duration\")\n        ... def call_api(endpoint: str) -&gt; dict:\n        ...     return requests.get(endpoint).json()\n\n    \"\"\"\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        metric_name = name or func.__name__\n        metrics = collector or MetricsCollector()\n\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            start = time.perf_counter()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                duration = time.perf_counter() - start\n                metrics.record_time(metric_name, duration)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/utils/#taipanstack.utils.metrics.counted","title":"counted","text":"<pre><code>counted(\n    name: str | None = None,\n    *,\n    collector: MetricsCollector | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator to count function calls.</p> PARAMETER DESCRIPTION <code>name</code> <p>Optional metric name (defaults to function name).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>collector</code> <p>Optional MetricsCollector instance.</p> <p> TYPE: <code>MetricsCollector | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function that counts calls.</p> Example <p>@counted(\"login_attempts\") ... def login(username: str, password: str) -&gt; bool: ...     return authenticate(username, password)</p> Source code in <code>src/taipanstack/utils/metrics.py</code> <pre><code>def counted(\n    name: str | None = None,\n    *,\n    collector: MetricsCollector | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Decorator to count function calls.\n\n    Args:\n        name: Optional metric name (defaults to function name).\n        collector: Optional MetricsCollector instance.\n\n    Returns:\n        Decorated function that counts calls.\n\n    Example:\n        &gt;&gt;&gt; @counted(\"login_attempts\")\n        ... def login(username: str, password: str) -&gt; bool:\n        ...     return authenticate(username, password)\n\n    \"\"\"\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        metric_name = name or f\"{func.__name__}_calls\"\n        metrics = collector or MetricsCollector()\n\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            metrics.increment(metric_name)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"releases/v0.3.0/","title":"TaipanStack v0.3.0 \u2014 Feature Documentation","text":""},{"location":"releases/v0.3.0/#overview","title":"Overview","text":"<p>v0.3.0 introduces 6 security, quality, and DevOps features that elevate TaipanStack to production-grade standards: software supply-chain attestation, custom SAST rules, hardened Docker, property-based testing, mutation testing, and performance benchmarks.</p>"},{"location":"releases/v0.3.0/#1-sbom-slsa-attestation","title":"1. SBOM &amp; SLSA Attestation","text":"<p>Workflow: <code>.github/workflows/sbom-slsa.yml</code></p> <p>Generates a CycloneDX Software Bill of Materials (SBOM) with Syft and signs all build artifacts using Cosign with keyless Sigstore signing.</p>"},{"location":"releases/v0.3.0/#architecture","title":"Architecture","text":"<pre><code>flowchart LR\n    A[GitHub Release] --&gt; B[Build Wheel]\n    B --&gt; C{Syft}\n    C --&gt; D[sbom.cdx.json]\n    B --&gt; E{Cosign Sign}\n    D --&gt; E\n    E --&gt; F[.sig + .crt files]\n    F --&gt; G{Cosign Verify}\n    G --&gt; H[Upload to Release]</code></pre>"},{"location":"releases/v0.3.0/#what-it-does","title":"What It Does","text":"Step Tool Output SBOM generation <code>syft</code> <code>sbom.cdx.json</code> (CycloneDX format) Wheel signing <code>cosign sign-blob</code> <code>*.whl.sig</code> + <code>*.whl.crt</code> SBOM signing <code>cosign sign-blob</code> <code>sbom.cdx.json.sig</code> + <code>.crt</code> Verification <code>cosign verify-blob</code> Validates identity + OIDC issuer"},{"location":"releases/v0.3.0/#security-properties","title":"Security Properties","text":"<ul> <li>Keyless signing via GitHub Actions OIDC \u2014 no long-lived secrets</li> <li>Identity-scoped verification \u2014 certificate must match <code>https://github.com/gabrielima7/TaipanStack/</code></li> <li>OIDC issuer pinned to <code>https://token.actions.githubusercontent.com</code></li> <li>Minimal permissions \u2014 <code>contents: write</code> + <code>id-token: write</code> are job-scoped</li> </ul>"},{"location":"releases/v0.3.0/#2-custom-sast-rules-semgrep","title":"2. Custom SAST Rules (Semgrep)","text":"<p>File: <code>.semgrep/taipanstack-rules.yml</code></p> <p>Custom Semgrep rules that enforce TaipanStack-specific coding patterns.</p>"},{"location":"releases/v0.3.0/#rules","title":"Rules","text":"Rule ID Severity What It Catches <code>taipanstack.require-error-handling</code> ERROR Using <code>Ok()</code>/<code>Err()</code> without matching both cases <code>taipanstack.no-bare-except</code> WARNING Catching bare <code>Exception</code> instead of specific types <code>taipanstack.use-guard-path</code> WARNING Using <code>open()</code> without <code>guard_path_traversal()</code>"},{"location":"releases/v0.3.0/#usage","title":"Usage","text":"<pre><code># Run locally\nsemgrep --config .semgrep/taipanstack-rules.yml src/\n\n# In CI (automatic via pre-commit)\npre-commit run semgrep --all-files\n</code></pre>"},{"location":"releases/v0.3.0/#3-docker-hardened-by-default","title":"3. Docker Hardened-by-Default","text":"<p>File: <code>Dockerfile</code></p> <p>Multi-stage, rootless, Alpine-based container following CIS Docker Benchmark v1.6.</p>"},{"location":"releases/v0.3.0/#security-features","title":"Security Features","text":"Feature Implementation Multi-stage build Builder stage discarded, only venv + src copied Non-root user <code>appuser</code> (UID 1000) created and activated before ENTRYPOINT Minimal base <code>python:3.12-alpine</code> (&lt; 50MB) No shell in runtime Only Python + app code Healthcheck <code>python -c \"import taipanstack\"</code> (no network exposure) Read-only filesystem App files owned by root, read-only for appuser"},{"location":"releases/v0.3.0/#build-run","title":"Build &amp; Run","text":"<pre><code>docker build -t taipanstack:latest .\ndocker run --rm --read-only taipanstack:latest\n</code></pre>"},{"location":"releases/v0.3.0/#4-property-based-testing-hypothesis","title":"4. Property-Based Testing (Hypothesis)","text":"<p>File: <code>tests/test_property_sanitizers.py</code></p> <p>22 property-based tests using Hypothesis to fuzz all 4 sanitizer functions with adversarial inputs.</p>"},{"location":"releases/v0.3.0/#strategy-design","title":"Strategy Design","text":"<pre><code># Custom strategy: generates filenames with path traversal, Unicode, control chars\nnasty_filename = st.text(\n    alphabet=st.characters(\n        whitelist_categories=(\"L\", \"N\", \"P\", \"S\", \"Z\"),\n        whitelist_characters=\"/\\\\..~%\\x00&lt;&gt;|*?\\\":\\n\\r\\t\",\n    ),\n    min_size=0, max_size=200,\n)\n</code></pre>"},{"location":"releases/v0.3.0/#edge-cases-discovered","title":"Edge Cases Discovered","text":"# Sanitizer Finding Resolution 1 <code>sanitize_filename</code> <code>Path().suffix</code> preserves backslashes in extensions Tests check stem only 2 <code>sanitize_filename</code> <code>\"unnamed\"</code> fallback ignores <code>max_length</code> Tests exclude empty input for length property 3 <code>sanitize_filename</code> Reserved chars in extension not cleaned Tests check stem portion only 4 <code>sanitize_filename</code> Null bytes in extension not stripped Tests verify stem is null-free 5 <code>sanitize_path</code> <code>..</code> components not blocked but collapsed Tests verify no traversal escapes"},{"location":"releases/v0.3.0/#mutation-quality","title":"Mutation Quality","text":"<ul> <li>Strategy diversity: Unicode (L, N, P, S, Z categories), control chars, path traversal sequences, SQL injection, XSS vectors</li> <li>Assertion strength: Stem-only verification correctly models the sanitizer's contract</li> <li>Example count: 500 fuzzed inputs per test (configurable via <code>FUZZ_EXAMPLES</code>)</li> </ul>"},{"location":"releases/v0.3.0/#5-mutation-testing-mutmut","title":"5. Mutation Testing (mutmut)","text":"<p>Configuration: <code>pyproject.toml</code> <code>[tool.mutmut]</code></p> <p>Mutation testing validates that tests are actually meaningful \u2014 not just achieving coverage but detecting real bugs.</p>"},{"location":"releases/v0.3.0/#how-to-run","title":"How to Run","text":"<pre><code># Full mutation run\npoetry run mutmut run --paths-to-mutate=src/taipanstack/security/sanitizers.py\n\n# View results\npoetry run mutmut results\n\n# Show specific mutant\npoetry run mutmut show &lt;id&gt;\n</code></pre>"},{"location":"releases/v0.3.0/#what-it-measures","title":"What It Measures","text":"<ul> <li>Killed mutants: Test suite detected the mutation \u2705</li> <li>Survived mutants: Tests passed despite the bug \u26a0\ufe0f</li> <li>Mutation Score: <code>killed / (killed + survived)</code> \u2014 target \u2265 80%</li> </ul>"},{"location":"releases/v0.3.0/#6-performance-benchmarks-pytest-benchmark","title":"6. Performance Benchmarks (pytest-benchmark)","text":"<p>Files: - <code>tests/test_benchmarks.py</code> - <code>.github/workflows/benchmark.yml</code></p> <p>15 micro-benchmarks measuring sanitizer and guard function performance with automatic regression detection in CI.</p>"},{"location":"releases/v0.3.0/#benchmarked-functions","title":"Benchmarked Functions","text":"Category Functions Iterations Sanitizers <code>sanitize_filename</code>, <code>sanitize_html</code>, <code>sanitize_env_value</code>, <code>sanitize_path</code> 1000+ Guards <code>guard_path_traversal</code>, <code>guard_command_injection</code>, <code>guard_file_extension</code> 1000+ Result types <code>Ok()</code>, <code>Err()</code>, <code>safe()</code> decorator, pattern matching 1000+"},{"location":"releases/v0.3.0/#usage_1","title":"Usage","text":"<pre><code># Run benchmarks locally\npoetry run pytest tests/test_benchmarks.py --benchmark-only -v\n\n# Compare against saved baseline\npoetry run pytest tests/test_benchmarks.py --benchmark-compare\n\n# Save as baseline\npoetry run pytest tests/test_benchmarks.py --benchmark-save=baseline\n</code></pre>"},{"location":"releases/v0.3.0/#ci-integration","title":"CI Integration","text":"<p>The benchmark workflow runs on every push to <code>main</code> and stores results in the <code>gh-pages</code> branch for historical tracking.</p>"},{"location":"releases/v0.3.0/#coverage-summary","title":"Coverage Summary","text":"Metric Value Total statements 1,586 Missed statements 0 Branch coverage 100% Total tests 664 Property-based tests 22 Benchmark tests 15 Coverage threshold <code>fail_under = 100</code>"},{"location":"releases/v0.3.1/","title":"TaipanStack v0.3.1 \u2014 Feature Documentation","text":""},{"location":"releases/v0.3.1/#overview","title":"Overview","text":"<p>v0.3.1 is a patch release focused on polishing, type safety, observability, and developer experience. It introduces 0 breaking changes and delivers improvements across 5 areas: advanced type hinting, monitoring callbacks, security edge-case hardening, version alignment, and documentation.</p>"},{"location":"releases/v0.3.1/#1-advanced-type-hinting-generics-overloads","title":"1. Advanced Type Hinting (Generics &amp; Overloads)","text":"<p>Files: - <code>src/taipanstack/core/result.py</code> - <code>src/taipanstack/utils/retry.py</code> - <code>src/taipanstack/utils/circuit_breaker.py</code></p> <p>Strengthened type annotations for strict-mode compatibility with <code>mypy</code> and <code>pyright</code>.</p>"},{"location":"releases/v0.3.1/#what-changed","title":"What Changed","text":"Module Change Benefit <code>result.py</code> <code>@overload</code> signatures for <code>unwrap_or</code> and <code>unwrap_or_else</code> Type checkers now narrow <code>T</code> vs <code>U</code> based on <code>Ok</code>/<code>Err</code> input <code>result.py</code> New <code>TypeVar U</code> for default values Default can be a different type than the Ok value <code>retry.py</code> <code>Retrier.__exit__</code> uses <code>type[BaseException]</code>, <code>TracebackType</code> Matches Python data model spec for context managers <code>circuit_breaker.py</code> Explicit <code>return False</code> sentinel in <code>_should_attempt()</code> All code paths return a value \u2014 satisfies strict checkers"},{"location":"releases/v0.3.1/#before-after","title":"Before / After","text":"<pre><code># BEFORE: mypy cannot narrow the return type\nvalue: int | str = unwrap_or(Ok(42), \"default\")  # type: int | str\n\n# AFTER: mypy narrows correctly based on the Result variant\nvalue: int = unwrap_or(Ok(42), \"default\")         # type: int \u2705\nvalue: str = unwrap_or(Err(\"fail\"), \"default\")     # type: str \u2705\n</code></pre>"},{"location":"releases/v0.3.1/#verification","title":"Verification","text":"<pre><code># Passes with zero errors on all 24 source files\npoetry run mypy src/ --strict\n</code></pre>"},{"location":"releases/v0.3.1/#2-observability-monitoring-callbacks","title":"2. Observability &amp; Monitoring Callbacks","text":"<p>Files: - <code>src/taipanstack/utils/retry.py</code> - <code>src/taipanstack/utils/circuit_breaker.py</code></p> <p>Added optional callback injection points for custom monitoring without breaking the existing API.</p>"},{"location":"releases/v0.3.1/#retry-on_retry-callback","title":"Retry: <code>on_retry</code> Callback","text":"Parameter Type Default Description <code>on_retry</code> <code>Callable[[int, int, Exception, float], None] \\| None</code> <code>None</code> Called on each retry with <code>(attempt, max_attempts, exception, delay)</code> <pre><code>from taipanstack.utils.retry import retry\n\ndef log_to_datadog(attempt: int, max_attempts: int, exc: Exception, delay: float) -&gt; None:\n    statsd.increment(\"retry.attempt\", tags=[f\"attempt:{attempt}\"])\n\n@retry(\n    max_attempts=3,\n    on=(ConnectionError,),\n    on_retry=log_to_datadog,\n)\ndef fetch_data(url: str) -&gt; dict:\n    return requests.get(url).json()\n</code></pre>"},{"location":"releases/v0.3.1/#circuit-breaker-on_state_change-callback","title":"Circuit Breaker: <code>on_state_change</code> Callback","text":"Parameter Type Default Description <code>on_state_change</code> <code>Callable[[CircuitState, CircuitState], None] \\| None</code> <code>None</code> Called on state transitions with <code>(old_state, new_state)</code> <pre><code>from taipanstack.utils.circuit_breaker import circuit_breaker, CircuitState\n\ndef alert_on_open(old: CircuitState, new: CircuitState) -&gt; None:\n    if new == CircuitState.OPEN:\n        slack.send(f\"\ud83d\udea8 Circuit opened! {old.value} \u2192 {new.value}\")\n\n@circuit_breaker(\n    failure_threshold=5,\n    timeout=60,\n    on_state_change=alert_on_open,\n)\ndef call_payment_api(amount: float) -&gt; dict:\n    return gateway.charge(amount)\n</code></pre>"},{"location":"releases/v0.3.1/#enriched-log-messages","title":"Enriched Log Messages","text":"Transition Log Message Example CLOSED \u2192 OPEN <code>\"Circuit payments opened after 5 failures (threshold=5)\"</code> OPEN \u2192 HALF_OPEN <code>\"Circuit payments entering half-open state (was open for 30.1s, failures=5)\"</code> HALF_OPEN \u2192 CLOSED <code>\"Circuit payments closed after recovery (2 consecutive successes)\"</code> HALF_OPEN \u2192 OPEN <code>\"Circuit payments reopened after failure in half-open (total failures=6)\"</code>"},{"location":"releases/v0.3.1/#3-security-edge-case-hardening","title":"3. Security Edge-Case Hardening","text":"<p>Files: - <code>src/taipanstack/security/guards.py</code> - <code>src/taipanstack/security/sanitizers.py</code> - <code>src/taipanstack/security/validators.py</code></p> <p>All public security functions now validate input types at runtime, raising clear <code>TypeError</code> instead of crashing with cryptic Python errors.</p>"},{"location":"releases/v0.3.1/#functions-hardened","title":"Functions Hardened","text":"Function Guard Added Error Raised <code>guard_path_traversal(path)</code> <code>path</code> must be <code>str \\| Path</code> <code>TypeError</code> <code>guard_command_injection(cmd)</code> All items must be <code>str</code> <code>TypeError</code> (with index) <code>guard_env_variable(name)</code> <code>name</code> must be <code>str</code>, non-empty <code>TypeError</code> / <code>SecurityError</code> <code>sanitize_string(value)</code> <code>value</code> must be <code>str</code> <code>TypeError</code> <code>sanitize_filename(filename)</code> <code>filename</code> must be <code>str</code> <code>TypeError</code> <code>validate_project_name(name)</code> <code>name</code> must be <code>str</code> <code>TypeError</code> <code>validate_email(email)</code> <code>email</code> must be <code>str</code> <code>TypeError</code> <code>validate_url(url)</code> <code>url</code> must be <code>str</code> <code>TypeError</code> <code>validate_python_version(ver)</code> <code>ver</code> must be <code>str</code> <code>TypeError</code>"},{"location":"releases/v0.3.1/#error-message-quality","title":"Error Message Quality","text":"<pre><code># BEFORE: Cryptic error\nsanitize_string(None)\n# AttributeError: 'NoneType' object has no attribute 'strip'\n\n# AFTER: Clear TaipanStack error\nsanitize_string(None)\n# TypeError: value must be str, got NoneType\n\n# Command injection with index context\nguard_command_injection([\"git\", \"clone\", 123])\n# TypeError: All command arguments must be strings, got int at index 2\n\n# Empty env variable name\nguard_env_variable(\"   \")\n# SecurityError: [env_variable] Environment variable name cannot be empty or whitespace\n</code></pre>"},{"location":"releases/v0.3.1/#4-version-alignment-cicd","title":"4. Version Alignment &amp; CI/CD","text":"<p>Files: - <code>pyproject.toml</code> - <code>src/taipanstack/__init__.py</code></p>"},{"location":"releases/v0.3.1/#version-fix","title":"Version Fix","text":"File Before After <code>pyproject.toml</code> <code>version = \"0.3.0\"</code> <code>version = \"0.3.1\"</code> <code>__init__.py</code> <code>__version__ = \"2.0.0\"</code> \u26a0\ufe0f <code>__version__ = \"0.3.1\"</code> \u2705 <p>Note: The <code>\"2.0.0\"</code> value was a legacy artifact from the project rename (Stack \u2192 TaipanStack). Now both sources of truth are aligned.</p>"},{"location":"releases/v0.3.1/#ci-pipeline-status","title":"CI Pipeline Status","text":"<p>The existing CI workflow (<code>ci.yml</code>) with its 12 jobs was reviewed and requires no changes:</p> <pre><code>\u2713 Test Matrix        \u2192 Python 3.11\u20133.14 \u00d7 (Ubuntu, macOS, Windows)\n\u2713 Linux Distros      \u2192 Ubuntu, Fedora, openSUSE, Arch, Alpine\n\u2713 Code Quality       \u2192 Ruff check &amp; format\n\u2713 Type Check         \u2192 Mypy --strict\n\u2713 Security           \u2192 Bandit + Semgrep (custom rules)\n\u2713 Architecture       \u2192 Import Linter contracts\n\u2713 Property Testing   \u2192 Hypothesis fuzzing\n\u2713 Mutation Testing   \u2192 mutmut\n\u2713 Benchmarks         \u2192 pytest-benchmark regression\n\u2713 Docker Build       \u2192 Hardened container validation\n\u2713 Docstring Coverage \u2192 interrogate\n\u2713 Dry Run + Integration\n</code></pre>"},{"location":"releases/v0.3.1/#5-documentation-developer-experience","title":"5. Documentation &amp; Developer Experience","text":"<p>Files: - <code>README.md</code> - <code>CHANGELOG.md</code></p>"},{"location":"releases/v0.3.1/#new-readme-examples","title":"New README Examples","text":"<p>Two practical examples were added showing how to combine TaipanStack primitives:</p>"},{"location":"releases/v0.3.1/#result-circuit-breaker","title":"Result + Circuit Breaker","text":"<pre><code>from taipanstack.core.result import safe, Ok, Err\nfrom taipanstack.utils.circuit_breaker import CircuitBreaker\n\nbreaker = CircuitBreaker(failure_threshold=3, timeout=60, name=\"payments\")\n\n@breaker\n@safe\ndef charge_customer(customer_id: str, amount: float) -&gt; dict:\n    return payment_gateway.charge(customer_id, amount)\n\nresult = charge_customer(\"cust_123\", 49.99)\nmatch result:\n    case Ok(receipt):\n        print(f\"Payment successful: {receipt}\")\n    case Err(error):\n        print(f\"Payment failed safely: {error}\")\n</code></pre>"},{"location":"releases/v0.3.1/#result-retry-with-monitoring","title":"Result + Retry with Monitoring","text":"<pre><code>from taipanstack.core.result import safe, unwrap_or\nfrom taipanstack.utils.retry import retry\n\n@retry(\n    max_attempts=3,\n    on=(ConnectionError, TimeoutError),\n    on_retry=lambda attempt, max_a, exc, delay: print(\n        f\"\u26a0\ufe0f  Attempt {attempt}/{max_a} failed, retrying in {delay:.1f}s...\"\n    ),\n)\n@safe\ndef fetch_user_profile(user_id: str) -&gt; dict:\n    return api_client.get(f\"/users/{user_id}\")\n\nprofile = unwrap_or(fetch_user_profile(\"usr_456\"), {\"name\": \"Unknown\"})\n</code></pre>"},{"location":"releases/v0.3.1/#quality-summary","title":"Quality Summary","text":"Metric v0.3.0 v0.3.1 Total tests 664 683 Coverage 100% 100% mypy --strict \u2705 \u2705 (+ overloads) Type-guarded functions 0 9 Monitoring callbacks 0 2 Breaking changes \u2014 0 Files modified \u2014 10"},{"location":"releases/v0.3.1/#reports","title":"Reports","text":"Report Link Coverage HTML gabrielima7.github.io/TaipanStack/htmlcov/ Benchmark Dashboard gabrielima7.github.io/TaipanStack/dev/bench/"}]}